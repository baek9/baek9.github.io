<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>https의 원리, 그리고 Self-signed SSL 까지 | code(evening);</title><meta name=keywords content="https,SSL,PKI"><meta name=description content="크로미움 분석으로 알게 된 사실 중 한 가지는 http보다 https로 접속한 웹 페이지에서 더 많은 자바스크립트 메소드를 사용할 수 있다는 것이다. 즉, 크롬은 스킴(scheme)에 따라 차등화된 권한을 웹 페이지에 부여한다. ”http://“, ”https://“, “chrome://“ 순으로 더 강력한? 메소드를 호출할 수 있다. chrome 스킴이야 당연히 크롬의 설정 페이지(chrome://settings)처럼 크롬의 운영과 관련된 부분들을 다루므로 기능적으로나 보안적으로나 다른 스킴들과는 다르긴 하겠지&mldr;라며 쉽게 납득했지만, http와 https 스킴의 권한이 다른 것에는 꽤 놀랐었다.
크롬이 http 스킴의 웹 페이지에 대해서 안전하지 않다고 경고하기 시작한 후부터 https 스킴이 아닌 웹 사이트를 찾아보기 힘들다."><meta name=author content="baek9"><link rel=canonical href=https://baek9.github.io/posts/2019-04-09-https%EC%9D%98_%EC%9B%90%EB%A6%AC_%EA%B7%B8%EB%A6%AC%EA%B3%A0_self-signed-ssl_%EA%B9%8C%EC%A7%80/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://baek9.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://baek9.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://baek9.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://baek9.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://baek9.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"https의 원리, 그리고 Self-signed SSL 까지","headline":"https의 원리, 그리고 Self-signed SSL 까지","alternativeHeadline":"","description":"크로미움 분석으로 알게 된 사실 중 한 가지는 http보다 https로 접속한 웹 페이지에서 더 많은 자바스크립트 메소드를 사용할 수 있다는 것이다. 즉, 크롬은 스킴(scheme)에 따라 차등화된 권한을 웹 페이지에 부여한다. ”http:\/\/“, ”https:\/\/“, “chrome:\/\/“ 순으로 더 강력한? 메소드를 호출할 수 있다. chrome 스킴이야 당연히 크롬의 설정 페이지(chrome:\/\/settings)처럼 크롬의 운영과 관련된 부분들을 다루므로 기능적으로나 보안적으로나 다른 스킴들과는 다르긴 하겠지\u0026hellip;라며 쉽게 납득했지만, http와 https 스킴의 권한이 다른 것에는 꽤 놀랐었다.\n크롬이 http 스킴의 웹 페이지에 대해서 안전하지 않다고 경고하기 시작한 후부터 https 스킴이 아닌 웹 사이트를 찾아보기 힘들다.","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/baek9.github.io\/posts\/2019-04-09-https%EC%9D%98_%EC%9B%90%EB%A6%AC_%EA%B7%B8%EB%A6%AC%EA%B3%A0_self-signed-ssl_%EA%B9%8C%EC%A7%80\/"},"author":{"@type":"Person","name":"baek9"},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"code(evening);","copyrightYear":"2019","dateCreated":"2019-04-09T22:21:14.00Z","datePublished":"2019-04-09T22:21:14.00Z","dateModified":"2019-04-09T22:21:14.00Z","publisher":{"@type":"Organization","name":"code(evening);","url":"https://baek9.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/baek9.github.io\/logo.png","width":"32","height":"32"}},"image":"https://baek9.github.io/logo.png","url":"https:\/\/baek9.github.io\/posts\/2019-04-09-https%EC%9D%98_%EC%9B%90%EB%A6%AC_%EA%B7%B8%EB%A6%AC%EA%B3%A0_self-signed-ssl_%EA%B9%8C%EC%A7%80\/","wordCount":"1813","genre":["https","SSL","PKI"],"keywords":[]}</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="https의 원리, 그리고 Self-signed SSL 까지"><meta property="og:description" content="크로미움 분석으로 알게 된 사실 중 한 가지는 http보다 https로 접속한 웹 페이지에서 더 많은 자바스크립트 메소드를 사용할 수 있다는 것이다. 즉, 크롬은 스킴(scheme)에 따라 차등화된 권한을 웹 페이지에 부여한다. ”http://“, ”https://“, “chrome://“ 순으로 더 강력한? 메소드를 호출할 수 있다. chrome 스킴이야 당연히 크롬의 설정 페이지(chrome://settings)처럼 크롬의 운영과 관련된 부분들을 다루므로 기능적으로나 보안적으로나 다른 스킴들과는 다르긴 하겠지&mldr;라며 쉽게 납득했지만, http와 https 스킴의 권한이 다른 것에는 꽤 놀랐었다.
크롬이 http 스킴의 웹 페이지에 대해서 안전하지 않다고 경고하기 시작한 후부터 https 스킴이 아닌 웹 사이트를 찾아보기 힘들다."><meta property="og:type" content="article"><meta property="og:url" content="https://baek9.github.io/posts/2019-04-09-https%EC%9D%98_%EC%9B%90%EB%A6%AC_%EA%B7%B8%EB%A6%AC%EA%B3%A0_self-signed-ssl_%EA%B9%8C%EC%A7%80/"><meta property="og:image" content="https://baek9.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-04-09T22:21:14+00:00"><meta property="article:modified_time" content="2019-04-09T22:21:14+00:00"><meta property="og:site_name" content="code(evening);"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://baek9.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="https의 원리, 그리고 Self-signed SSL 까지"><meta name=twitter:description content="크로미움 분석으로 알게 된 사실 중 한 가지는 http보다 https로 접속한 웹 페이지에서 더 많은 자바스크립트 메소드를 사용할 수 있다는 것이다. 즉, 크롬은 스킴(scheme)에 따라 차등화된 권한을 웹 페이지에 부여한다. ”http://“, ”https://“, “chrome://“ 순으로 더 강력한? 메소드를 호출할 수 있다. chrome 스킴이야 당연히 크롬의 설정 페이지(chrome://settings)처럼 크롬의 운영과 관련된 부분들을 다루므로 기능적으로나 보안적으로나 다른 스킴들과는 다르긴 하겠지&mldr;라며 쉽게 납득했지만, http와 https 스킴의 권한이 다른 것에는 꽤 놀랐었다.
크롬이 http 스킴의 웹 페이지에 대해서 안전하지 않다고 경고하기 시작한 후부터 https 스킴이 아닌 웹 사이트를 찾아보기 힘들다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://baek9.github.io/posts/"},{"@type":"ListItem","position":2,"name":"https의 원리, 그리고 Self-signed SSL 까지","item":"https://baek9.github.io/posts/2019-04-09-https%EC%9D%98_%EC%9B%90%EB%A6%AC_%EA%B7%B8%EB%A6%AC%EA%B3%A0_self-signed-ssl_%EA%B9%8C%EC%A7%80/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"https의 원리, 그리고 Self-signed SSL 까지","name":"https의 원리, 그리고 Self-signed SSL 까지","description":"크로미움 분석으로 알게 된 사실 중 한 가지는 http보다 https로 접속한 웹 페이지에서 더 많은 자바스크립트 메소드를 사용할 수 있다는 것이다. 즉, 크롬은 스킴(scheme)에 따라 차등화된 권한을 웹 페이지에 부여한다. ”http://“, ”https://“, “chrome://“ 순으로 더 강력한? 메소드를 호출할 수 있다. chrome 스킴이야 당연히 크롬의 설정 페이지(chrome://settings)처럼 크롬의 운영과 관련된 부분들을 다루므로 기능적으로나 보안적으로나 다른 스킴들과는 다르긴 하겠지\u0026hellip;라며 쉽게 납득했지만, http와 https 스킴의 권한이 다른 것에는 꽤 놀랐었다.\n크롬이 http 스킴의 웹 페이지에 대해서 안전하지 않다고 경고하기 시작한 후부터 https 스킴이 아닌 웹 사이트를 찾아보기 힘들다.","keywords":["https","SSL","PKI"],"articleBody":"크로미움 분석으로 알게 된 사실 중 한 가지는 http보다 https로 접속한 웹 페이지에서 더 많은 자바스크립트 메소드를 사용할 수 있다는 것이다. 즉, 크롬은 스킴(scheme)에 따라 차등화된 권한을 웹 페이지에 부여한다. ”http://“, ”https://“, “chrome://“ 순으로 더 강력한? 메소드를 호출할 수 있다. chrome 스킴이야 당연히 크롬의 설정 페이지(chrome://settings)처럼 크롬의 운영과 관련된 부분들을 다루므로 기능적으로나 보안적으로나 다른 스킴들과는 다르긴 하겠지…라며 쉽게 납득했지만, http와 https 스킴의 권한이 다른 것에는 꽤 놀랐었다.\n크롬이 http 스킴의 웹 페이지에 대해서 안전하지 않다고 경고하기 시작한 후부터 https 스킴이 아닌 웹 사이트를 찾아보기 힘들다. 그런데 웹 개발자 입장에서는 https로 개발 중인 웹 사이트를 테스트하는 것이 번거롭다. 웹 사이트가 안전한 사이트라고 증명해주는 인증서(certificate)를 구매하여야 하기 때문이다. 본 포스트 작성에 참고한 사이트들을 보면서 좀 더 쉽게 테스트 하고자 하는 개발자들이 이미 수두룩 했음을 알 수 있었다.\n만약, localhost를 https로 접속할 수 있다면 얼마나 좋을까하는 생각을 했다. 나는 웹 개발에도 관심은 있지만 그보다 자바스크립트 엔진 쪽에 관심이 있어서 찾아보기 시작했는데 이미 훌륭한 시행착오들이 있었다. 그냥 그대로 따라하면 되는 부분들이다. 하지만 인증서를 비롯한 https의 전반적인 원리가 궁금하여 함께 따로 정리해 보았다. 참고로, 자바스크립트 엔진은 https에 대하여 ‘secure context’에서 구동되어 더 많은 권한의 메소드들의 호출을 허락한다. 아래 웹 페이지를 참고.\nhttps://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts\nHTTPS(HTTP over SSL) 의문 한 가지. 크롬은 http 스킴의 웹 페이지를 접속하면 안전하지 않은 사이트라고 경고한다. 즉, https 스킴의 웹 페이지는 안전하다는 것인데 안전하다는 것을 크롬은 어떻게 알 수 있는 것인가? 바로 절대적으로 신뢰할 수 있는 제3자를 통해 알 수 있는 것이다. 이 때 사용되는 것이 인증서이다. 전체적인 메커니즘을 이해하기 위해서는 먼저 ‘비대칭 암호화’(Asymmetric Cryptography), ‘전자서명’(Digital Signature)에 대하여 알아야 했다.\n비대칭 암호화(= 공개키 암호화) 대칭키 암호화에서는 데이터를 암호화하거나 복호화하는데 사용되는 키가 동일하다. 대칭키 암호화의 단점은 키가 유출되면 데이터도 유출된다는 점이다. 이 때문에 혼자만 키를 간직하는 파일 압축, 윈도우의 볼륨 암호 기능인 비트락커(BitLocker) 등에서 사용된다. 만약, 두 사람이 “안전한” 암호 통신을 하고 싶다면? 이 경우에 비대칭 암호화가 활용된다. 비대칭 암호화에서는 암호화할 때 쓰는 키와 복호화할 때 쓰는 키가 다르다. 쌍을 이루는 두 키, A와 B가 있을 때, A키로 암호화하면 B키로 복호화되고, B키로 암호화하면 A키로 복호화된다. 본 포스트는 비대칭 암호화에 대한 수학적인 내용은 담지 않았다.\n공개키 서명, 공개키 검증 과연 비대칭 암호화는 어디에 쓸모 있는 걸까? 앞서 말했듯이 두 사람 간의 암호 통신에 사용될 수 있다. 이를 위해서 키 쌍 중 하나를 비밀키(private key), 다른 하나를 공개키(public key)로 지정한다. 비밀키는 절대 공개되어서는 안되며, 공개키는 공개되어도 무방하다. 아니, 오히려 공개되어야 의미가 있다. 키를 공개한다고? 이 특이한 특징 때문에 비대칭 암호화를 “공개키 암호화”라고도 부른다. 공개키 암호화는 크게 두 부분으로 동작한다. 바로 ‘공개키 서명’과 ‘공개키 검증’이 바로 그것이다. 먼저, 공개키 서명은 다음의 절차로 이루어진다.\n공개키 서명 철수 : 데이터 원문과 원문을 비밀키로 암호화한 암호문을 함께 송신. 영희 : 원문과 암호문를 수신하여 원문과 공개키로 복호화한 복호문을 비교. 영희는 복호문과 원문이 일치할 때 데이터를 보낸 사람이 철수임을 확신할 수 있다. 이 때 철수가 보낸 암호문은 공개키를 가지고 있는 누구라도 복호화 될 수 있다. 이 과정이 인감을 이용한 진본 확인, 신원 확인 절차와 동일하기 때문에 “서명”이라고 불린다.\n그리고 공개키 암호는 다음의 절차로 이루어진다.\n공개키 암호 영희 : 데이터 원문을 공개키로 암호화한 암호문을 송신. 철수 : 암호문을 수신하여 비밀키로 복호화. 앞의 공개키 서명 과정과 비교하면 철수는 비공개키를 이용하여 영희가 공개키로 암호화한 암호문을 복호화할 수 있다. 다만, 비밀키는 말그대로 철수만 갖고 있으므로 철수 외 그 누구도 암호문을 복호화할 수 없다. 즉, 두 사람은 서로의 공개키를 교환함으로써 서로의 신원을 확신하고, 서로의 공개키로 데이터를 암호화하여 보냄으로써 상호 간에 안전하게 데이터를 주고 받을 수 있다.\n공개키 암호만을 이용한 전자 통신은 성능이 떨어진다고 알려져 있다. 개인적인 생각으로 다자간 암호 통신 시에는 송신할 데이터를 모든 수신자들의 공개키로 각각 암호화해야하고, 각 수신자들에게 개별적으로 송신해야 할 것 이므로 매우 불편할 것이다. 실제로 공개키 암호화는 대칭키를 공유하기 위한 용도로만 사용하며 그 대칭키를 이용하여 실제 통신이 이루어진다.\n공개키 기반 구조(PKI : Public Key Infrastructure) 단순히 공개키 암호화만 알아서 암호 통신은 불가능하다. ‘공개키 기반 구조’는 공개키 암호화를 기반으로 한 암호 통신에 필요한 모든 요소들을 포함하는 용어이다. 여기에는 이후에 설명할 인증서(Certificate)와 인증기관(CA : Certificate Authority)에 대한 내용이 포함된다.\nSSL(Secure Sockets Layer) 웹이 발전하면서 웹을 통한 안전한 통신이 요구되었다. 왜냐면 사용자가 보는 웹 페이지가 변조되었는지 여부를 판단해야 했기에. 이를 위해 일찍이 넷스케이프(Netscape)사는 PKI 구조에 따라 ‘SSL’을 개발하였다. 이후, 표준으로 제정되면서 TLS(Transport Layer Security)라는 이름으로 변경되었다. https는 이 SSL 위에서 동작하는 웹 프로토콜이다.\nHTTPS의 전체적인 동작 과정 https 프로토콜의 동작은 다음과 같다. 앞서 공개키 서명에서는 송신자가 데이터의 원본과 원본을 비밀키로 암호화한 암호문을 보내면 수신자는 공개키로 암호문을 복호화한 복호문과 원문의 일치 여부로 송신자의 신원을 검증할 수 있다. 이 때, 암호문을 “송신자의 서명\"이라고 한다. 이와 비슷하게 https 프로토콜에서 데이터의 원본에는 사용자가 접속하고자 하는 ‘서버의 도메인’과 ‘서버 공개키’가 들어있다. 데이터의 원본과 ‘서버 서명’을 묶어 ‘인증서’(certificate)라고 부른다.(실제로는 서버 서명이 아니라 CA 서명이 들어 있지만 설명을 위해서 가정헤보면) 어? 그런데 서버 공개키가 인증서에 들어간다? 앞서 살펴본 공개키 서명에서는 수신자가 송신자의 공개키를 이미 알고 있다고 가정한 부분이 깨진다. 이는 심각한 보안 상 결함으로 이어진다. 예를 들어 “https://www.google.com”에 접속한 사용자가 구글 서버로부터 구글 서버의 공개키를 포함한 인증서를 받았다. 당연히 인증서에 포함된 공개키로 해당 인증서는 검증이 될 것이다. 문제는 구글 서버가 진짜 구글 서버가 맞느냐는 것이다. 만약, 사용자가 주소를 잘못 쳐서 접속한 “googlee.com”이 마침 악의적인 의도를 가지고 “google.com\"을 사칭하고 있는 상황이라면?\n인증기관(CA : Certificate Authority) 결국, 구글 서버로부터 받은 것으로 추측되는 인증서가 신뢰가능한 지를 검증해야만 한다. 그렇지 않으면 우리는 미국 산호세에 있는 구글 본사에 직접 가서 구글 서버의 공개키를 받아야만 한다. 마찬가지로 네이버를 이용하려면 분당에 있는 네이버 본사에 직접 가서 공개키를 받아야만 한다. 하지만, 그럴 수 없으니 제3자를 통해서 인증서를 검증하는 부분이 PKI에 포함되어 있다.이 제3자를 ‘인증기관’(CA : Certificate Authority)이라고 한다. CA의 역할은 사용자가 접속한 서버의 인증서를 신뢰할 수 있는지를 대신 검증해주는 것이다.\n인증서 체인(Certificate Chain) 다시, 사용자가 “https://www.google.com”에 접속하는 시나리오에서 사용자는 구글 서버로부터 인증서를 전달받을 것이다. 이 인증서에는 ‘서버 도메인’, ‘서버 공개키’ 뿐만 아니라 ‘CA 도메인’, 그리고 서버가 아닌 ‘CA 서명’이 들어있다. 이 인증서를 검증하려면 서명이 CA의 것이기 때문에 CA의 공개키가 필요하다. 이 때, 인증서의 서명이 검증되었다는 의미는 다음과 같이 연쇄 해석이 가능하다.\n인증서의 서명이 검증되었다 == 인증서는 CA에 의해 서명된 진본이다 == 인증서를 보낸 서버는 믿을 수 있다 == 인증서에 포함된 공개키는 서버의 것이 맞다 그렇다면 CA의 공개키는 도대체 어디에 있는가? 바로 운영체제와 크롬 브라우저가 미리 포함하고 있는 ‘CA 인증서’에 있다. 결국, CA 인증서로 서버 인증서를 검증하는 모양새이다. 이를 ‘인증서 체인’이라고 한다. CA 자체는 어찌할 수 없이 신뢰할 수 밖에 없다. 이 때문에 크랙된 운영체제나 웹 브라우저를 쓰는 등 믿을 수 없는 소스로부터 받은 소프트웨어를 사용하는 것은 보안 상 좋지 않다.\nSelf-signed SSL 위와 같은 복잡한 PKI 구조 때문에 https로 서비스되는 웹 사이트를 미리 테스트하는 것은 쉽지 않다. 테스트 하고자 하는 웹 사이트의 도메인과 서버 공개키를 CA에 보내어 서버 인증서를 발급받아야 하기 때문이다. 다시 한 번 정리하면 이 인증서에는 다음의 내용이 포함되어 있다.\n서버 도메인 서버 공개키 CA 도메인 CA 서명 결국 웹 사이트 개발자 입장에서 겨우 테스트용 웹 사이트를 위해 CA로부터 인증서를 발급받아야 하는 상황이다.(어차피, 엄격한 CA는 테스트 용도의 웹 사이트를 위해 인증서를 발급해 줄 것 같지 않다)\n만약, 내가 직접 CA의 역할을 할 수 있다면 얼마나 좋을까. 이미 Self Signed SSL이라는 키워드로 검색하면 많은 글들이 쏟아져 나온다. 그 중에서도 localhost에 대한 인증서를 스스로 직접 서명하는 과정을 소개하려고 한다.\n1. (CA측) CA 비밀키 생성 CA(root CA)의 역할을 하기 위해서는 CA로서의 비밀키와 공개키를 생성해야 한다. 아래 명령어는 OpenSSL이라는 프로그램을 이용하여 대표적인 공개키 암호 알고리즘인 RSA(Rivest–Shamir–Adleman)로 길이가 2048 비트인 비밀키를 생성하여 rootCA.key에 저장한다. des3 옵션은 비밀키를 대칭키 알고리즘인 3DES(Triple Data Encryption Standard)로 한번 더 암호화하라는 의미이다. 비밀키는 절대 유출되어서는 안되기 때문에 한번 더 보호하기 위함이며, 아래 명령어를 입력하는 즉시 암호키를 요구할 것이다.\n$ openssl genrsa -des3 -out rootCA.key 2048 // rootCA.key 생성됨 2. (CA측) CA 인증서 생성 아래 명령어를 통하여 CA용 비밀키와 쌍을 이루는 CA용 공개키를 생성하고, 그 공개키와 CA의 기본 정보에 대해 CA 비밀키로 서명한 CA 인증서를 생성한다. 이렇게 생성된 CA 인증서는 웹 브라우저 또는 운영체제에 신뢰할 수 있는 인증서로 등록할 것이다. 추후, 로컬 웹 서버로부터 받는 서버 인증서의 신뢰 여부는 이 CA 인증서를 이용하여 판단된다. x509 옵션은 X.509 포맷의 인증서를 생성하겠다는 의미이고, nodes(node의 복수형이 아니다…) 옵션은 CA용 공개키를 암호화하지 않겠다는 의미이다. sha256 옵션은 서명 생성에 SHA256 해시 알고리즘을 사용하겠다는 의미이다. 사실, 서명 생성 시에 데이터를 그대로 비밀키로 암호화하는 것이 아니라 데이터를 해시값으로 가공한 것을 비밀키로 암호화한다. days 옵션은 인증서의 유효기간을 설정하는 것이다. 이 명령어는 1,024일간 유효한 인증서를 생성한다. 결국 rootCA.crt라는 CA 인증서가 생성된다.\n$ openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.crt // rootCA.crt 생성됨 위 명령어를 치면 CA 공개키 생성 및 CA 서명 생성에 CA 개인키를 쓰기 위하여 암호를 물어볼 것이다. 이 암호는 앞서 CA 개인키를 DES3로 암호화할 때 쓴 대칭키를 입력하면 된다. 이어 CA로서의 기본적인 정보를 몇 가지 물어볼 것이다. 이를 테면 CA의 국적이라던지 이름, 도메인 등의 정보들이다.\n3. (서버측) 서버 비밀키 생성(생략 가능) 이제 서버 비밀키를 생성할 차례이다. CA 비밀키를 생성했던 방법과 동일하게 아래처럼 입력하면 된다. des3 옵션이 없는데 des3 옵션은 기본 옵션이다. 일단, 서버 비밀키를 지금 생성하지 않고 다음 과정에서 생성할 것이다.\n$ openssl genrsa -out server.key 2048 // server.key 생성됨 4. (서버측) 서버 비밀키/공개키 및 CSR 생성 통상적으로 웹 개발자는 서버 도메인과 서버 공개키를 CA에 보내어 CA 개인키로 서명이 된 서버 인증서를 발급하여 달라는 요청을 하여야 한다. 이 요청을 CSR(Certificate Signing Request)이라고 한다. CSR 생성에 필요한 정보들은 별도의 파일에 작성하여 OpenSSL에 제공할 수 있다. 아래 server.csr.cnf를 보면 “[dn]” 항목에 서버의 정보를 적게 되어 있다. 이 때, CN 필드를 정확히 입력해야 한다. 아무리 CA의 서명을 받은 서버 인증서라도 사용자가 접속하려는 사이트의 도메인이 CN 필드에 기재된 도메인에 포함되지 않으면 브라우저는 접속을 차단한다. 차단되는 이유는 CSR 작성 시에 오타가 발생했거나, CA의 비밀키가 유출되어 엉뚱한 사이트에 대해 인증서가 잘못 발급된 경우를 의심해 볼 수 있다. 두 경우 모두 심각한 보안 사고로 이어진다. 디지노타라는 CA는 비밀키가 유출되어 파산에 이르렀다고 한다.\n# server.csr.cnf (for creating csr) [req] default_bits = 2048 prompt = no default_md = sha256 distinguished_name = dn [dn] C=US ST=RandomState L=RandomCity O=RandomOrganization OU=RandomOrganizationUnit emailAddress=hello@example.com CN = localhost 아래 명령어는 위에서 작성한 server.csr.cnf에 기재된 서버 정보를 바탕으로 server.csr이라는 CSR을 생성한다. 이 때, newkey 옵션으로 생성한 서버 개인키도 활용한다. CSR 생성 시에 서버 공개키가 포함된다고 설명했는데, 사실, OpenSSL이 비밀키를 생성할 적에는 비밀키 뿐만 아니라 공개키도 이미 포함을 하고 있다. 이에 대해서는 아래에 추가로 설명한다. 어쨋든 이렇게 만들어진 CSR은 서버 비밀키로 서명된다. 결국, 서버 비밀키인 server.key와 CSR인 server.csr이 생성된다.\n$ openssl req -new -sha256 -nodes -out server.csr \\ -newkey rsa:2048 -keyout server.key \\ -config \u003c( cat server.csr.cnf ) // server.key, server.csr 생성됨 5. (CA측) 서버 인증서 생성 CA 입장에서는 서버로부터 받은 CSR을 CA 개인키로 서명한 서버 인증서를 서버에 보내주어야 한다. 인증서 생성에는 확장 필드를 추가할 수 있다. 아래의 v3.ext 파일을 보면 인증서의 포맷인 X.509의 표준의 세 번째 확장에 대한 내용이 담겨있다. 이 확장에는 하나의 인증서로 여러 도메인을 신뢰하게 해 줄 수 있는 SAN(Subject Alternative Name) 필드 등이 있다.\n# v3.ext(for creating X509 v3 certificate) authorityKeyIdentifier=keyid,issuer basicConstraints=CA:FALSE keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment subjectAltName = @alt_names [alt_names] DNS.1 = localhost 아래 명령어는 앞서 생성한 CSR인 server.csr에 앞서 작성한 v3.ext에 담긴 X.509 확장 필드를 붙여 서버 인증서를 생성한다. 이 인증서는 CA 개인키인 rootCA.key로 서명된다. 결국, server.crt라는 서버 인증서가 만들어진다.\n$ openssl x509 -req -in server.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial \\ -out server.crt -days 500 -sha256 -extfile v3.ext // server.crt 생성됨 +. 비밀키/공개키의 생성 위 과정을 따라하면서 궁금했던 점은 비밀키와 공개키는 한 쌍임에도 불구하고 명시적으로 공개키를 생성하는 과정이 없었다는 점이다. 비밀키에 공개키가 포함되어 있는 것이 아닌가 의심 되었지만 OpenSSL의 genrsa 명령어는 비밀키를 생성한다고만 되어있었다. 실제로 genrsa로 생성되는 것은 비밀키와 공개키 생성에 필요한 여러가지 팩터들이고, 이들을 이용하여 필요할 때마다 빠르게 비밀키와 공개키를 생성한다고 한다.\nhttps://stackoverflow.com/a/44350448\n","wordCount":"1813","inLanguage":"en","datePublished":"2019-04-09T22:21:14Z","dateModified":"2019-04-09T22:21:14Z","author":{"@type":"Person","name":"baek9"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://baek9.github.io/posts/2019-04-09-https%EC%9D%98_%EC%9B%90%EB%A6%AC_%EA%B7%B8%EB%A6%AC%EA%B3%A0_self-signed-ssl_%EA%B9%8C%EC%A7%80/"},"publisher":{"@type":"Organization","name":"code(evening);","logo":{"@type":"ImageObject","url":"https://baek9.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://baek9.github.io/ accesskey=h title="늦은 밤 개발 일기 (Alt + H)"><img src=https://baek9.github.io/logo.png style=border-radius:5px;padding:6px;background:#fff alt=logo aria-label=logo height=45>늦은 밤 개발 일기</a><div class="social-icons logo-switches"><ul id=menu><li><a href=https://linkedin.com/in/thnam target=_blank rel="noopener noreferrer me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li><a href=https://twitter.com/thnam_ target=_blank rel="noopener noreferrer me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></li><li><a href=https://github.com/baek9 target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://baek9.github.io/index.xml target=_blank rel="noopener noreferrer me" title=Rss><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></li></ul></div></div><ul id=menu><li><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></li><li><a href=https://baek9.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://baek9.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://baek9.github.io/about_me/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://baek9.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://baek9.github.io/posts/>Posts</a></div><h1 class=post-title>https의 원리, 그리고 Self-signed SSL 까지</h1><div class=post-meta><span title='2019-04-09 22:21:14 +0000 UTC'>April 9, 2019</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1813 words&nbsp;·&nbsp;baek9</div></header><div class=post-content><p>크로미움 분석으로 알게 된 사실 중 한 가지는 http보다 https로 접속한 웹 페이지에서 더 많은 자바스크립트 메소드를 사용할 수 있다는 것이다. 즉, 크롬은 스킴(scheme)에 따라 차등화된 권한을 웹 페이지에 부여한다. ”http://“, ”https://“, “chrome://“ 순으로 더 강력한? 메소드를 호출할 수 있다. chrome 스킴이야 당연히 크롬의 설정 페이지(chrome://settings)처럼 크롬의 운영과 관련된 부분들을 다루므로 기능적으로나 보안적으로나 다른 스킴들과는 다르긴 하겠지&mldr;라며 쉽게 납득했지만, http와 https 스킴의 권한이 다른 것에는 꽤 놀랐었다.</p><p>크롬이 http 스킴의 웹 페이지에 대해서 안전하지 않다고 경고하기 시작한 후부터 https 스킴이 아닌 웹 사이트를 찾아보기 힘들다. 그런데 웹 개발자 입장에서는 https로 개발 중인 웹 사이트를 테스트하는 것이 번거롭다. 웹 사이트가 안전한 사이트라고 증명해주는 인증서(certificate)를 구매하여야 하기 때문이다. 본 포스트 작성에 참고한 사이트들을 보면서 좀 더 쉽게 테스트 하고자 하는 개발자들이 이미 수두룩 했음을 알 수 있었다.</p><p>만약, localhost를 https로 접속할 수 있다면 얼마나 좋을까하는 생각을 했다. 나는 웹 개발에도 관심은 있지만 그보다 자바스크립트 엔진 쪽에 관심이 있어서 찾아보기 시작했는데 이미 훌륭한 시행착오들이 있었다. 그냥 그대로 따라하면 되는 부분들이다. 하지만 인증서를 비롯한 https의 전반적인 원리가 궁금하여 함께 따로 정리해 보았다. 참고로, 자바스크립트 엔진은 https에 대하여 &lsquo;secure context&rsquo;에서 구동되어 더 많은 권한의 메소드들의 호출을 허락한다. 아래 웹 페이지를 참고.</p><p><a href=https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts>https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts</a></p><h2 id=httpshttp-over-ssl>HTTPS(HTTP over SSL)<a hidden class=anchor aria-hidden=true href=#httpshttp-over-ssl>#</a></h2><p>의문 한 가지. 크롬은 http 스킴의 웹 페이지를 접속하면 안전하지 않은 사이트라고 경고한다. 즉, https 스킴의 웹 페이지는 안전하다는 것인데 안전하다는 것을 크롬은 어떻게 알 수 있는 것인가? 바로 절대적으로 신뢰할 수 있는 제3자를 통해 알 수 있는 것이다. 이 때 사용되는 것이 인증서이다. 전체적인 메커니즘을 이해하기 위해서는 먼저 &lsquo;비대칭 암호화&rsquo;(Asymmetric Cryptography), &lsquo;전자서명&rsquo;(Digital Signature)에 대하여 알아야 했다.</p><h2 id=비대칭-암호화-공개키-암호화>비대칭 암호화(= 공개키 암호화)<a hidden class=anchor aria-hidden=true href=#비대칭-암호화-공개키-암호화>#</a></h2><p>대칭키 암호화에서는 데이터를 암호화하거나 복호화하는데 사용되는 키가 동일하다. 대칭키 암호화의 단점은 키가 유출되면 데이터도 유출된다는 점이다. 이 때문에 혼자만 키를 간직하는 파일 압축, 윈도우의 볼륨 암호 기능인 비트락커(BitLocker) 등에서 사용된다. 만약, 두 사람이 &ldquo;안전한&rdquo; 암호 통신을 하고 싶다면? 이 경우에 비대칭 암호화가 활용된다. 비대칭 암호화에서는 암호화할 때 쓰는 키와 복호화할 때 쓰는 키가 다르다. 쌍을 이루는 두 키, A와 B가 있을 때, A키로 암호화하면 B키로 복호화되고, B키로 암호화하면 A키로 복호화된다. 본 포스트는 비대칭 암호화에 대한 수학적인 내용은 담지 않았다.</p><h2 id=공개키-서명-공개키-검증>공개키 서명, 공개키 검증<a hidden class=anchor aria-hidden=true href=#공개키-서명-공개키-검증>#</a></h2><p>과연 비대칭 암호화는 어디에 쓸모 있는 걸까? 앞서 말했듯이 두 사람 간의 암호 통신에 사용될 수 있다. 이를 위해서 키 쌍 중 하나를 비밀키(private key), 다른 하나를 공개키(public key)로 지정한다. 비밀키는 절대 공개되어서는 안되며, 공개키는 공개되어도 무방하다. 아니, 오히려 공개되어야 의미가 있다. 키를 공개한다고? 이 특이한 특징 때문에 비대칭 암호화를 “공개키 암호화”라고도 부른다. 공개키 암호화는 크게 두 부분으로 동작한다. 바로 &lsquo;공개키 서명&rsquo;과 &lsquo;공개키 검증&rsquo;이 바로 그것이다. 먼저, 공개키 서명은 다음의 절차로 이루어진다.</p><h4 id=공개키-서명>공개키 서명<a hidden class=anchor aria-hidden=true href=#공개키-서명>#</a></h4><ol><li>철수 : 데이터 원문과 원문을 비밀키로 암호화한 암호문을 함께 송신.</li><li>영희 : 원문과 암호문를 수신하여 원문과 공개키로 복호화한 복호문을 비교.</li></ol><p>영희는 복호문과 원문이 일치할 때 데이터를 보낸 사람이 철수임을 확신할 수 있다. 이 때 철수가 보낸 암호문은 공개키를 가지고 있는 누구라도 복호화 될 수 있다. 이 과정이 인감을 이용한 진본 확인, 신원 확인 절차와 동일하기 때문에 “서명”이라고 불린다.</p><p>그리고 공개키 암호는 다음의 절차로 이루어진다.</p><h4 id=공개키-암호>공개키 암호<a hidden class=anchor aria-hidden=true href=#공개키-암호>#</a></h4><ol><li>영희 : 데이터 원문을 공개키로 암호화한 암호문을 송신.</li><li>철수 : 암호문을 수신하여 비밀키로 복호화.</li></ol><p>앞의 공개키 서명 과정과 비교하면 철수는 비공개키를 이용하여 영희가 공개키로 암호화한 암호문을 복호화할 수 있다. 다만, 비밀키는 말그대로 철수만 갖고 있으므로 철수 외 그 누구도 암호문을 복호화할 수 없다. 즉, 두 사람은 서로의 공개키를 교환함으로써 서로의 신원을 확신하고, 서로의 공개키로 데이터를 암호화하여 보냄으로써 상호 간에 안전하게 데이터를 주고 받을 수 있다.</p><p>공개키 암호만을 이용한 전자 통신은 성능이 떨어진다고 알려져 있다. 개인적인 생각으로 다자간 암호 통신 시에는 송신할 데이터를 모든 수신자들의 공개키로 각각 암호화해야하고, 각 수신자들에게 개별적으로 송신해야 할 것 이므로 매우 불편할 것이다. 실제로 공개키 암호화는 대칭키를 공유하기 위한 용도로만 사용하며 그 대칭키를 이용하여 실제 통신이 이루어진다.</p><h2 id=공개키-기반-구조pki--public-key-infrastructure>공개키 기반 구조(PKI : Public Key Infrastructure)<a hidden class=anchor aria-hidden=true href=#공개키-기반-구조pki--public-key-infrastructure>#</a></h2><p>단순히 공개키 암호화만 알아서 암호 통신은 불가능하다. &lsquo;공개키 기반 구조&rsquo;는 공개키 암호화를 기반으로 한 암호 통신에 필요한 모든 요소들을 포함하는 용어이다. 여기에는 이후에 설명할 인증서(Certificate)와 인증기관(CA : Certificate Authority)에 대한 내용이 포함된다.</p><h2 id=sslsecure-sockets-layer>SSL(Secure Sockets Layer)<a hidden class=anchor aria-hidden=true href=#sslsecure-sockets-layer>#</a></h2><p>웹이 발전하면서 웹을 통한 안전한 통신이 요구되었다. 왜냐면 사용자가 보는 웹 페이지가 변조되었는지 여부를 판단해야 했기에. 이를 위해 일찍이 넷스케이프(Netscape)사는 PKI 구조에 따라 &lsquo;SSL&rsquo;을 개발하였다. 이후, 표준으로 제정되면서 TLS(Transport Layer Security)라는 이름으로 변경되었다. https는 이 SSL 위에서 동작하는 웹 프로토콜이다.</p><h2 id=https의-전체적인-동작-과정>HTTPS의 전체적인 동작 과정<a hidden class=anchor aria-hidden=true href=#https의-전체적인-동작-과정>#</a></h2><p>https 프로토콜의 동작은 다음과 같다. 앞서 공개키 서명에서는 송신자가 데이터의 원본과 원본을 비밀키로 암호화한 암호문을 보내면 수신자는 공개키로 암호문을 복호화한 복호문과 원문의 일치 여부로 송신자의 신원을 검증할 수 있다. 이 때, 암호문을 “송신자의 서명"이라고 한다. 이와 비슷하게 https 프로토콜에서 데이터의 원본에는 사용자가 접속하고자 하는 &lsquo;서버의 도메인&rsquo;과 &lsquo;서버 공개키&rsquo;가 들어있다. 데이터의 원본과 &lsquo;서버 서명&rsquo;을 묶어 &lsquo;인증서&rsquo;(certificate)라고 부른다.(실제로는 서버 서명이 아니라 CA 서명이 들어 있지만 설명을 위해서 가정헤보면) 어? 그런데 서버 공개키가 인증서에 들어간다? 앞서 살펴본 공개키 서명에서는 수신자가 송신자의 공개키를 이미 알고 있다고 가정한 부분이 깨진다. 이는 심각한 보안 상 결함으로 이어진다. 예를 들어 “https://www.google.com”에 접속한 사용자가 구글 서버로부터 구글 서버의 공개키를 포함한 인증서를 받았다. 당연히 인증서에 포함된 공개키로 해당 인증서는 검증이 될 것이다. 문제는 구글 서버가 진짜 구글 서버가 맞느냐는 것이다. 만약, 사용자가 주소를 잘못 쳐서 접속한 “googlee.com”이 마침 악의적인 의도를 가지고 &ldquo;google.com"을 사칭하고 있는 상황이라면?</p><h2 id=인증기관ca--certificate-authority>인증기관(CA : Certificate Authority)<a hidden class=anchor aria-hidden=true href=#인증기관ca--certificate-authority>#</a></h2><p>결국, 구글 서버로부터 받은 것으로 추측되는 인증서가 신뢰가능한 지를 검증해야만 한다. 그렇지 않으면 우리는 미국 산호세에 있는 구글 본사에 직접 가서 구글 서버의 공개키를 받아야만 한다. 마찬가지로 네이버를 이용하려면 분당에 있는 네이버 본사에 직접 가서 공개키를 받아야만 한다. 하지만, 그럴 수 없으니 제3자를 통해서 인증서를 검증하는 부분이 PKI에 포함되어 있다.이 제3자를 &lsquo;인증기관&rsquo;(CA : Certificate Authority)이라고 한다. CA의 역할은 사용자가 접속한 서버의 인증서를 신뢰할 수 있는지를 대신 검증해주는 것이다.</p><h2 id=인증서-체인certificate-chain>인증서 체인(Certificate Chain)<a hidden class=anchor aria-hidden=true href=#인증서-체인certificate-chain>#</a></h2><p>다시, 사용자가 “https://www.google.com”에 접속하는 시나리오에서 사용자는 구글 서버로부터 인증서를 전달받을 것이다. 이 인증서에는 &lsquo;서버 도메인&rsquo;, &lsquo;서버 공개키&rsquo; 뿐만 아니라 &lsquo;CA 도메인&rsquo;, 그리고 서버가 아닌 &lsquo;CA 서명&rsquo;이 들어있다. 이 인증서를 검증하려면 서명이 CA의 것이기 때문에 CA의 공개키가 필요하다. 이 때, 인증서의 서명이 검증되었다는 의미는 다음과 같이 연쇄 해석이 가능하다.</p><ul><li>인증서의 서명이 검증되었다</li><li>== 인증서는 CA에 의해 서명된 진본이다</li><li>== 인증서를 보낸 서버는 믿을 수 있다</li><li>== 인증서에 포함된 공개키는 서버의 것이 맞다</li></ul><p>그렇다면 CA의 공개키는 도대체 어디에 있는가? 바로 운영체제와 크롬 브라우저가 미리 포함하고 있는 &lsquo;CA 인증서&rsquo;에 있다. 결국, CA 인증서로 서버 인증서를 검증하는 모양새이다. 이를 &lsquo;인증서 체인&rsquo;이라고 한다. CA 자체는 어찌할 수 없이 신뢰할 수 밖에 없다. 이 때문에 크랙된 운영체제나 웹 브라우저를 쓰는 등 믿을 수 없는 소스로부터 받은 소프트웨어를 사용하는 것은 보안 상 좋지 않다.</p><h2 id=self-signed-ssl>Self-signed SSL<a hidden class=anchor aria-hidden=true href=#self-signed-ssl>#</a></h2><p>위와 같은 복잡한 PKI 구조 때문에 https로 서비스되는 웹 사이트를 미리 테스트하는 것은 쉽지 않다. 테스트 하고자 하는 웹 사이트의 도메인과 서버 공개키를 CA에 보내어 서버 인증서를 발급받아야 하기 때문이다. 다시 한 번 정리하면 이 인증서에는 다음의 내용이 포함되어 있다.</p><ul><li>서버 도메인</li><li>서버 공개키</li><li>CA 도메인</li><li>CA 서명</li></ul><p>결국 웹 사이트 개발자 입장에서 겨우 테스트용 웹 사이트를 위해 CA로부터 인증서를 발급받아야 하는 상황이다.(어차피, 엄격한 CA는 테스트 용도의 웹 사이트를 위해 인증서를 발급해 줄 것 같지 않다)</p><p>만약, 내가 직접 CA의 역할을 할 수 있다면 얼마나 좋을까. 이미 Self Signed SSL이라는 키워드로 검색하면 많은 글들이 쏟아져 나온다. 그 중에서도 localhost에 대한 인증서를 스스로 직접 서명하는 과정을 소개하려고 한다.</p><h4 id=1-ca측-ca-비밀키-생성>1. (CA측) CA 비밀키 생성<a hidden class=anchor aria-hidden=true href=#1-ca측-ca-비밀키-생성>#</a></h4><p>CA(root CA)의 역할을 하기 위해서는 CA로서의 비밀키와 공개키를 생성해야 한다. 아래 명령어는 OpenSSL이라는 프로그램을 이용하여 대표적인 공개키 암호 알고리즘인 RSA(Rivest–Shamir–Adleman)로 길이가 2048 비트인 비밀키를 생성하여 rootCA.key에 저장한다. des3 옵션은 비밀키를 대칭키 알고리즘인 3DES(Triple Data Encryption Standard)로 한번 더 암호화하라는 의미이다. 비밀키는 절대 유출되어서는 안되기 때문에 한번 더 보호하기 위함이며, 아래 명령어를 입력하는 즉시 암호키를 요구할 것이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl genrsa -des3 -out rootCA.key <span class=m>2048</span>
</span></span><span class=line><span class=cl>// rootCA.key 생성됨
</span></span></code></pre></div><h4 id=2-ca측-ca-인증서-생성>2. (CA측) CA 인증서 생성<a hidden class=anchor aria-hidden=true href=#2-ca측-ca-인증서-생성>#</a></h4><p>아래 명령어를 통하여 CA용 비밀키와 쌍을 이루는 CA용 공개키를 생성하고, 그 공개키와 CA의 기본 정보에 대해 CA 비밀키로 서명한 CA 인증서를 생성한다. 이렇게 생성된 CA 인증서는 웹 브라우저 또는 운영체제에 신뢰할 수 있는 인증서로 등록할 것이다. 추후, 로컬 웹 서버로부터 받는 서버 인증서의 신뢰 여부는 이 CA 인증서를 이용하여 판단된다. x509 옵션은 X.509 포맷의 인증서를 생성하겠다는 의미이고, nodes(node의 복수형이 아니다&mldr;) 옵션은 CA용 공개키를 암호화하지 않겠다는 의미이다. sha256 옵션은 서명 생성에 SHA256 해시 알고리즘을 사용하겠다는 의미이다. 사실, 서명 생성 시에 데이터를 그대로 비밀키로 암호화하는 것이 아니라 데이터를 해시값으로 가공한 것을 비밀키로 암호화한다. days 옵션은 인증서의 유효기간을 설정하는 것이다. 이 명령어는 1,024일간 유효한 인증서를 생성한다. 결국 rootCA.crt라는 CA 인증서가 생성된다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl req -x509 -new -nodes -key rootCA.key -sha256 -days <span class=m>1024</span> -out rootCA.crt
</span></span><span class=line><span class=cl>// rootCA.crt 생성됨
</span></span></code></pre></div><p>위 명령어를 치면 CA 공개키 생성 및 CA 서명 생성에 CA 개인키를 쓰기 위하여 암호를 물어볼 것이다. 이 암호는 앞서 CA 개인키를 DES3로 암호화할 때 쓴 대칭키를 입력하면 된다. 이어 CA로서의 기본적인 정보를 몇 가지 물어볼 것이다. 이를 테면 CA의 국적이라던지 이름, 도메인 등의 정보들이다.</p><h4 id=3-서버측-서버-비밀키-생성생략-가능>3. (서버측) 서버 비밀키 생성(생략 가능)<a hidden class=anchor aria-hidden=true href=#3-서버측-서버-비밀키-생성생략-가능>#</a></h4><p>이제 서버 비밀키를 생성할 차례이다. CA 비밀키를 생성했던 방법과 동일하게 아래처럼 입력하면 된다. des3 옵션이 없는데 des3 옵션은 기본 옵션이다. 일단, 서버 비밀키를 지금 생성하지 않고 다음 과정에서 생성할 것이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl genrsa -out server.key <span class=m>2048</span> 
</span></span><span class=line><span class=cl>// server.key 생성됨
</span></span></code></pre></div><h4 id=4-서버측-서버-비밀키공개키-및-csr-생성>4. (서버측) 서버 비밀키/공개키 및 CSR 생성<a hidden class=anchor aria-hidden=true href=#4-서버측-서버-비밀키공개키-및-csr-생성>#</a></h4><p>통상적으로 웹 개발자는 서버 도메인과 서버 공개키를 CA에 보내어 CA 개인키로 서명이 된 서버 인증서를 발급하여 달라는 요청을 하여야 한다. 이 요청을 CSR(Certificate Signing Request)이라고 한다. CSR 생성에 필요한 정보들은 별도의 파일에 작성하여 OpenSSL에 제공할 수 있다. 아래 server.csr.cnf를 보면 “[dn]” 항목에 서버의 정보를 적게 되어 있다. 이 때, CN 필드를 정확히 입력해야 한다. 아무리 CA의 서명을 받은 서버 인증서라도 사용자가 접속하려는 사이트의 도메인이 CN 필드에 기재된 도메인에 포함되지 않으면 브라우저는 접속을 차단한다. 차단되는 이유는 CSR 작성 시에 오타가 발생했거나, CA의 비밀키가 유출되어 엉뚱한 사이트에 대해 인증서가 잘못 발급된 경우를 의심해 볼 수 있다. 두 경우 모두 심각한 보안 사고로 이어진다. 디지노타라는 CA는 비밀키가 유출되어 파산에 이르렀다고 한다.</p><pre tabindex=0><code># server.csr.cnf (for creating csr)
[req]
default_bits = 2048
prompt = no
default_md = sha256
distinguished_name = dn

[dn]
C=US
ST=RandomState
L=RandomCity
O=RandomOrganization
OU=RandomOrganizationUnit
emailAddress=hello@example.com
CN = localhost
</code></pre><p>아래 명령어는 위에서 작성한 server.csr.cnf에 기재된 서버 정보를 바탕으로 server.csr이라는 CSR을 생성한다. 이 때, newkey 옵션으로 생성한 서버 개인키도 활용한다. CSR 생성 시에 서버 공개키가 포함된다고 설명했는데, 사실, OpenSSL이 비밀키를 생성할 적에는 비밀키 뿐만 아니라 공개키도 이미 포함을 하고 있다. 이에 대해서는 아래에 추가로 설명한다. 어쨋든 이렇게 만들어진 CSR은 서버 비밀키로 서명된다. 결국, 서버 비밀키인 server.key와 CSR인 server.csr이 생성된다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl req -new -sha256 -nodes -out server.csr <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -newkey rsa:2048 -keyout server.key <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -config &lt;<span class=o>(</span> cat server.csr.cnf <span class=o>)</span>
</span></span><span class=line><span class=cl> // server.key, server.csr 생성됨
</span></span></code></pre></div><h4 id=5-ca측-서버-인증서-생성>5. (CA측) 서버 인증서 생성<a hidden class=anchor aria-hidden=true href=#5-ca측-서버-인증서-생성>#</a></h4><p>CA 입장에서는 서버로부터 받은 CSR을 CA 개인키로 서명한 서버 인증서를 서버에 보내주어야 한다. 인증서 생성에는 확장 필드를 추가할 수 있다. 아래의 v3.ext 파일을 보면 인증서의 포맷인 X.509의 표준의 세 번째 확장에 대한 내용이 담겨있다. 이 확장에는 하나의 인증서로 여러 도메인을 신뢰하게 해 줄 수 있는 SAN(Subject Alternative Name) 필드 등이 있다.</p><pre tabindex=0><code># v3.ext(for creating X509 v3 certificate)
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
</code></pre><p>아래 명령어는 앞서 생성한 CSR인 server.csr에 앞서 작성한 v3.ext에 담긴 X.509 확장 필드를 붙여 서버 인증서를 생성한다. 이 인증서는 CA 개인키인 rootCA.key로 서명된다. 결국, server.crt라는 서버 인증서가 만들어진다.</p><pre tabindex=0><code class=language-script data-lang=script>$ openssl x509 -req -in server.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial \
-out server.crt -days 500 -sha256 -extfile v3.ext
// server.crt 생성됨
</code></pre><h4 id=-비밀키공개키의-생성>+. 비밀키/공개키의 생성<a hidden class=anchor aria-hidden=true href=#-비밀키공개키의-생성>#</a></h4><p>위 과정을 따라하면서 궁금했던 점은 비밀키와 공개키는 한 쌍임에도 불구하고 명시적으로 공개키를 생성하는 과정이 없었다는 점이다. 비밀키에 공개키가 포함되어 있는 것이 아닌가 의심 되었지만 OpenSSL의 genrsa 명령어는 비밀키를 생성한다고만 되어있었다. 실제로 genrsa로 생성되는 것은 비밀키와 공개키 생성에 필요한 여러가지 팩터들이고, 이들을 이용하여 필요할 때마다 빠르게 비밀키와 공개키를 생성한다고 한다.</p><p><a href=https://stackoverflow.com/a/44350448>https://stackoverflow.com/a/44350448</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://baek9.github.io/tags/https/>https</a></li><li><a href=https://baek9.github.io/tags/ssl/>SSL</a></li><li><a href=https://baek9.github.io/tags/pki/>PKI</a></li></ul><nav class=paginav><a class=prev href=https://baek9.github.io/posts/2019-08-02-%ED%81%AC%EB%A1%ACos_%EA%B0%9C%EB%B0%9C_%EB%B0%8F_%EB%94%94%EB%B2%84%EA%B9%85_%ED%8C%81/><span class=title>« Prev</span><br><span>크롬OS 개발 및 디버깅 팁</span></a>
<a class=next href=https://baek9.github.io/posts/2018-04-02-integer_overflow_in_regexp_of_v8/><span class=title>Next »</span><br><span>Integer Overflow in V8</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share https의 원리, 그리고 Self-signed SSL 까지 on twitter" href="https://twitter.com/intent/tweet/?text=https%ec%9d%98%20%ec%9b%90%eb%a6%ac%2c%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20Self-signed%20SSL%20%ea%b9%8c%ec%a7%80&url=https%3a%2f%2fbaek9.github.io%2fposts%2f2019-04-09-https%25EC%259D%2598_%25EC%259B%2590%25EB%25A6%25AC_%25EA%25B7%25B8%25EB%25A6%25AC%25EA%25B3%25A0_self-signed-ssl_%25EA%25B9%258C%25EC%25A7%2580%2f&hashtags=https%2cSSL%2cPKI"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share https의 원리, 그리고 Self-signed SSL 까지 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbaek9.github.io%2fposts%2f2019-04-09-https%25EC%259D%2598_%25EC%259B%2590%25EB%25A6%25AC_%25EA%25B7%25B8%25EB%25A6%25AC%25EA%25B3%25A0_self-signed-ssl_%25EA%25B9%258C%25EC%25A7%2580%2f&title=https%ec%9d%98%20%ec%9b%90%eb%a6%ac%2c%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20Self-signed%20SSL%20%ea%b9%8c%ec%a7%80&summary=https%ec%9d%98%20%ec%9b%90%eb%a6%ac%2c%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20Self-signed%20SSL%20%ea%b9%8c%ec%a7%80&source=https%3a%2f%2fbaek9.github.io%2fposts%2f2019-04-09-https%25EC%259D%2598_%25EC%259B%2590%25EB%25A6%25AC_%25EA%25B7%25B8%25EB%25A6%25AC%25EA%25B3%25A0_self-signed-ssl_%25EA%25B9%258C%25EC%25A7%2580%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share https의 원리, 그리고 Self-signed SSL 까지 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbaek9.github.io%2fposts%2f2019-04-09-https%25EC%259D%2598_%25EC%259B%2590%25EB%25A6%25AC_%25EA%25B7%25B8%25EB%25A6%25AC%25EA%25B3%25A0_self-signed-ssl_%25EA%25B9%258C%25EC%25A7%2580%2f&title=https%ec%9d%98%20%ec%9b%90%eb%a6%ac%2c%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20Self-signed%20SSL%20%ea%b9%8c%ec%a7%80"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share https의 원리, 그리고 Self-signed SSL 까지 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbaek9.github.io%2fposts%2f2019-04-09-https%25EC%259D%2598_%25EC%259B%2590%25EB%25A6%25AC_%25EA%25B7%25B8%25EB%25A6%25AC%25EA%25B3%25A0_self-signed-ssl_%25EA%25B9%258C%25EC%25A7%2580%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share https의 원리, 그리고 Self-signed SSL 까지 on whatsapp" href="https://api.whatsapp.com/send?text=https%ec%9d%98%20%ec%9b%90%eb%a6%ac%2c%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20Self-signed%20SSL%20%ea%b9%8c%ec%a7%80%20-%20https%3a%2f%2fbaek9.github.io%2fposts%2f2019-04-09-https%25EC%259D%2598_%25EC%259B%2590%25EB%25A6%25AC_%25EA%25B7%25B8%25EB%25A6%25AC%25EA%25B3%25A0_self-signed-ssl_%25EA%25B9%258C%25EC%25A7%2580%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share https의 원리, 그리고 Self-signed SSL 까지 on telegram" href="https://telegram.me/share/url?text=https%ec%9d%98%20%ec%9b%90%eb%a6%ac%2c%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20Self-signed%20SSL%20%ea%b9%8c%ec%a7%80&url=https%3a%2f%2fbaek9.github.io%2fposts%2f2019-04-09-https%25EC%259D%2598_%25EC%259B%2590%25EB%25A6%25AC_%25EA%25B7%25B8%25EB%25A6%25AC%25EA%25B3%25A0_self-signed-ssl_%25EA%25B9%258C%25EC%25A7%2580%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement('script');t.src='https://evening-code.disqus.com/embed.js',t.setAttribute('data-timestamp',+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8701780565311862" crossorigin=anonymous></script></article></main><footer class=footer><div style="position:relative;margin-bottom:var(--gap);padding:var(--gap);background:#000;border-radius:var(--radius);transition:transform .1s;border:0 solid var(--border)"><span>NEIGHBORS</span><div style=line-height:10px;display:flex;flex-wrap:wrap><a style=border-bottom:none href=https://beintous.net rel="noopener noreferrer" target=_blank title="SEO "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/beintous.png alt=SEO aria-label=logo height=30></span></a>
<a style=border-bottom:none href=https://traceback.co.kr rel="noopener noreferrer" target=_blank title="코딩 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/traceback.png alt=코딩 aria-label=logo height=30></span></a>
<a style=border-bottom:none href=https://neppster.com rel="noopener noreferrer" target=_blank title="노하우 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/neppster.png alt=노하우 aria-label=logo height=30></span></a>
<a style=border-bottom:none href=https://traceback.co.kr rel="noopener noreferrer" target=_blank title="대구 언어치료 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/hannuri.jpeg alt="대구 언어치료" aria-label=logo height=30></span></a>
<a style=border-bottom:none href=https://neppster.com rel="noopener noreferrer" target=_blank title="거제 꽃집 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/jules.jpeg alt="거제 꽃집" aria-label=logo height=30></span></a></div></div></footer><footer class=footer><span>&copy; 2022 <a href=https://baek9.github.io/>code(evening);</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>