<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>evening(code)</title>
    <description>늦은 밤 개발 일기
</description>
    <link>http://baek9.github.io/</link>
    <atom:link href="http://baek9.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 29 Mar 2020 02:41:09 +0900</pubDate>
    <lastBuildDate>Sun, 29 Mar 2020 02:41:09 +0900</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>크로미움에 기여하기</title>
        <description>&lt;p&gt;크로미움에 처음 기여할 때 밟았던 절차와 내가 생각하는 주의 사항들을 기록한다. 크로미움은 큰 오픈소스 커뮤니티이기 때문에 관련 절차를 매우 상세하게 소개하고 있다. 검색해보면 참고해 볼 만한 제 3자의 포스트들도 많다. 나는 주로 아래 세 개의 자료를 참고하였다. 처음 두 개는 크로미움 커뮤니티에서 제공하는 공식 문서이다. 마지막은 제 3자가 작성한 것으로 좀 더 친근하고 쉽게 작성되어 기여 절차를 직관적이고 빠르게 이해하는 데 도움이 되었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/docs/contributing.md&quot;&gt;Contributing to Chromium&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/docs/commit_checklist.md&quot;&gt;Commit Checklist for Chromium Workflow&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://meowni.ca/posts/chromium-101/&quot;&gt;Contributing to Chromium: an illustrated guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;signing-the-clacontributer-license-agreement&quot;&gt;Signing the CLA(Contributer License Agreement)&lt;/h1&gt;

&lt;p&gt;크로미움에 코드를 기여하기 위해서는 CLA라는 계약에 서명하여야 한다. 이는 기여하는 코드에 대한 각종 권리를 포기하겠다는 의미이다. 오픈소스 프로젝트 입장에서 법적 분쟁을 피하기 위한 장치이다. 서명하기 위해서는 구글 계정으로 로그인 한 후, &lt;a href=&quot;https://cla.developers.google.com/&quot;&gt;https://cla.developers.google.com/&lt;/a&gt;에서 안내하는 절차를 밟으면 된다.&lt;/p&gt;

&lt;h1 id=&quot;git-settings&quot;&gt;Git settings&lt;/h1&gt;

&lt;p&gt;크로미움의 코드 기여는 gerrit이라는 코드 리뷰 시스템에 의해 통제된다. 이 통제에 따르기 위해 아래의 명령어를 순서대로 실행하여 내 개발 머신의 git을 적절히 설정하여야 한다. 이름과 이메일 주소는 gerrit에 업로드한 코드의 기여자를 식별하고 해당 코드에 관련한 각종 알림을 기여자에게 송신하는 데 사용되므로 정확하게 입력하여야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config --global user.name &quot;내 이름&quot;
git config --global user.email &quot;myemail@chromium.org&quot;
git config --global core.autocrlf false
git config --global core.filemode false
git config --local gerrit.host true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;hunting-or-searching-bugs&quot;&gt;Hunting or Searching bugs&lt;/h1&gt;

&lt;p&gt;크로미움에서 버그를 직접 찾아서 고친다면? 그렇다면 당신은 버그 헌터로서의 감각과 개발자로서의 실력을 동시에 겸비한 고수임이 틀림없다. 특히, 크로미움은 오랫동안 활발하게 개발 중이므로 버그를 찾기가 쉽지 않다. 물론, 새로운 기능을 제안하고 그것을 구현하는 것으로 기여할 수 있지만, 그 경우에는 메일링리스트(mailinglist)를 통하여 다른 개발자들을 설득하고 함께 기능을 설계 및 개발해야 하기에 더더욱 쉽지 않은 일일 것이다.&lt;/p&gt;

&lt;p&gt;크로미움은 버그 추적 관리 시스템을 제공한다. &lt;a href=&quot;https://bug.chromium.org&quot;&gt;https://bugs.chromium.org&lt;/a&gt;에 접속하면 전 세계의 크로미움 사용자들이 제보한 버그들의 목록을 확인할 수 있다. “available” 상태의 버그는 얼마든지 도전해도 좋다. 특히, “GoodFirstBug” 라벨이 달린 버그는 크로미움에 막 입문한 개발자들이 도전하기 좋다고 한다. 필터 기능이 있으니 손쉽게 검색해 볼 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;building-chromium&quot;&gt;Building Chromium&lt;/h1&gt;

&lt;p&gt;크로미움의 소스코드를 받아 빌드하고 버그를 재현한 뒤 그 원인을 분석하여야 한다. 관련 절차는 &lt;a href=&quot;https://www.chromium.org/developers/how-tos/get-the-code&quot;&gt;Get the Code: Checkout, Build, &amp;amp; Run Chromium&lt;/a&gt;에 플랫폼 별로 상세히 소개되어 있으니 참고하면 된다.&lt;/p&gt;

&lt;p&gt;버그의 원인을 분석하거나 수정하기 위해 별도의 브랜치(branch)에서 작업하는 것이 권장된다. git이 제공하는 기능인 브랜치는 서로 간에 독립적이어서 협업에 주로 활용되는 기능이다. 여기서는 독립적인 여러 개의 버그를 동시에 위한 수정하기 위한 용도로 사용된다. 아래의 명령어는 “mychange”라는 브랜치를 생성함과 동시에 해당 브랜치로 전환하는 명령어이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout -b mychange -t origin/master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;fixing-the-bug&quot;&gt;Fixing the bug&lt;/h1&gt;

&lt;p&gt;버그의 내용이 주석(comment)을 수정하는 류의 간단한 문제가 아니라 기능 수정 등을 요하는 문제일 경우에 유의해야 할 사항이 있다. 만약, 수정하고자 하는 기능을 테스트하기 위한 기능이 존재한다면 기여하려는 코드를 테스트하기 위한 코드도 기여하여야 한다는 것이다. 귀찮은 일이다. 하지만 미래에 해당 버그가 다시 발현되는 경우도 있기에 버그 추적이 필요하고, 이는 오픈소스 커뮤니티에서 매우 중요한 부분이라고 생각된다. 생략하더라도 추후에 리뷰어(reviewer)로부터 테스트 코드를 추가하도록 요구받을 수 있으니 미리 염두에 두는 것이 좋을 것 같다. 테스트와 관련하여서는 &lt;a href=&quot;https://www.chromium.org/developers/testing&quot;&gt;Testing and infrastructure
&lt;/a&gt;을 참고하면 된다.&lt;/p&gt;

&lt;p&gt;크로미움의 코드는 구글(google)이 정한 코딩 스타일 규칙에 따라 작성되어야 한다. 따라서 기여하기 위한 코드도 이 규칙에 따라 작성되어야 한다. 아래 명령어는 수정한 코드가 그 규칙에 맞는지를 자동으로 검사해준다. 어느 수준까지 검사해 주는 지는 모르겠으나 개인적으로 불 필요한 공백이 제거되는 것은 확인할 수 있었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git cl format --js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또 한 가지, 크로미움에 처음 기여한다면 반드시 “AUTHOR”라는 파일에 본인의 이름과 이메일을 한 줄 추가하여야 한다. 추가할 때는 이 파일이 사전식 순서(lexicographical order)를 따른다는 점에 유의하여야 한다. 최종적으로 기여가 완료되면 컨트리뷰터(contributor)라는 칭호에 대한 확실한 근거가 생기는 셈이다.&lt;/p&gt;

&lt;p&gt;기여하고 싶은 모든 수정 사항들은 gerrit에 업로드하기 위해 준비 상태로 전환하여야 한다. 수정된 코드를 일괄적으로 업로드 준비 상태로 만들기 위해서는 아래의 git 명령어를 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add .
git commit -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;uploading-the-code&quot;&gt;Uploading the code&lt;/h1&gt;

&lt;p&gt;준비된 코드를 아래의 명령어로 gerrit에 업로드 할 수 있다. 이 때, 수정한 내용에 대하여 간단한 요약문을 작성하도록 요구받는다. 이 요약문에 어떤 버그를 해결하려고 하는지, 어느 코드를 어떻게 수정했는지를 간결하게 작성해야 한다. 무엇보다 이 요약문은 공개되는 내용이기에 매우 신경써서 작성하여야 한다. 그만큼 작성하는 데 있어서 반드시 지켜야 하는 규칙들이 존재한다. 이 때문에 영어와 크로미움에 기여하는 것이 익숙치 않은 분은 미리 요약문을 준비해 두는 것이 좋다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git cl upload
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;요약문은 제목과 본문의 두 부분으로 구성된다. &lt;a href=&quot;https://chris.beams.io/posts/git-commit/&quot;&gt;How to Write a Git Commit Message&lt;/a&gt;에 좋은 요약문을 쓰는 방법이 상세하게 소개되어 있다. 아래는 요약문 작성 시에 지켜야 할 규칙들을 나름대로 요약해 본 것 이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;그런 분은 없겠지만 만국 공통어인 영어로 작성해야 한다.&lt;/li&gt;
  &lt;li&gt;제목은 대문자로 시작하며 한 줄이어야 한다. 50자 내외로 작성하라고 하는데 조금 초과해도 괜찮을 것으로 생각된다.&lt;/li&gt;
  &lt;li&gt;제목과 본문의 사이에는 1개의 빈 줄을 삽입해야 한다. gerrit은 이 빈 줄을 기준으로 요약문의 제목과 본문을 구분한다.&lt;/li&gt;
  &lt;li&gt;크로미움의 소스코드와 마찬가지로 본문의 가로 길이는 72 byte를 초과하지 않아야 한다.&lt;/li&gt;
  &lt;li&gt;해결하고자 하는 버그의 번호(issue number)를 기재한다. 기여가 이루어지면 버그 추적 관리 시스템 상의 해당 버그에 댓글의 형태로 기여 내용에 대한 정보가 자동으로 등록된다. 즉, 이를 통해 버그 추적 관리 시스템과 코드 리뷰 시스템이 연동된다.&lt;/li&gt;
  &lt;li&gt;가능하면 해당 버그가 해결되었는지 확인할 수 있는 방법을 기재한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아래는 크로미움 커뮤니티에서 제공하는 요약문의 작성 예시이다. 더 많은 예시를 확인하고 싶으면 &lt;a href=&quot;https://chomium-review.googlesorce.com&quot;&gt;https://chromium-review.googlesource.com&lt;/a&gt;에서 확인 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Summary of change (one line)

Longer description of change addressing as appropriate: why the change
is made, context if it is part of many changes, description of previous
behavior and newly introduced differences, etc.

Long lines should be wrapped to 72 columns for easier log message
viewing in terminals.

Bug: 123456
Test: Load example.com/page.html and click the foo-button; see
crbug.com/123456 for more details.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;code-review&quot;&gt;Code review&lt;/h1&gt;

&lt;p&gt;업로드를 완료했고 앞서 git 설정 시에 이름과 이메일 주소를 잘 입력했다면, gerrit이 제공하는 웹 사이트인 &lt;a href=&quot;https://chromium-review.googlesource.com&quot;&gt;https://chromium-review.googlesource.com&lt;/a&gt;에서 업로드 된 내용을 확인할 수 있다. 그러나 아직 기여가 이루어진 것이 아니다. status가 “WIP(Work in progress)”임을 확인할 수 있을 텐데 이는 아직 작업 중이라는 의미이다. 이 상태에서는 이후에도 여러 번의 업로드를 통해 기여 내용을 수정하는 것이 가능하다. 만약, 기여하기에 완벽하다는 생각이 들면 리뷰어(reviewer)에게 리뷰, 즉, 첨삭을 받아야 한다. 리뷰어를 추가하는 것은 웹에서 이루어진다. 누구를 추가할 지는 아래의 git 명령어를 통해 추천받을 수 있다. 적당한 리뷰어를 2, 3명 정도 추가하면 된다. 최종적으로 2명 이상의 리뷰를 받으면 수정한 내용이 자동적으로 크로미움 코드 저장소인 &lt;a href=&quot;https://chromium.googlesource.com/chromium/src.git&quot;&gt;https://chromium.googlesource.com/chromium/src.git&lt;/a&gt;에 반영되며 이로써 기여의 모든 절차가 마무리된다.&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Jan 2020 08:00:06 +0900</pubDate>
        <link>http://baek9.github.io/chromium/2020/01/11/%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90_%EA%B8%B0%EC%97%AC%ED%95%98%EA%B8%B0.html</link>
        <guid isPermaLink="true">http://baek9.github.io/chromium/2020/01/11/%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90_%EA%B8%B0%EC%97%AC%ED%95%98%EA%B8%B0.html</guid>
        
        <category>tips</category>
        
        
        <category>Chromium</category>
        
      </item>
    
      <item>
        <title>Ash part 1</title>
        <description>&lt;p&gt;Ash(Aura Shell)는 Aura를 기반으로 하는 쉘이다. Shell 클래스가 핵심적인 역할을 하는 것으로 보인다. Shell 객체는 싱글턴 객체이고 init 메소드를 통하여 컨트롤러라 불리우는 다른 객체를 여럿 생성하고 초기화한다. 아래는 배경화면에 관한 컨트롤러를 생성 및 초기화 하는 부분이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ash::Shell::Init() {
...
wallpaper_controller_ = std::make_unique&amp;lt;WallpaperControllerImpl&amp;gt;(local_state_);
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;싱글턴 객체인 Shell 객체를 전역적으로 참조하기 위하여 Shell 클래스는 정적 메소드인 Get 메소드를 제공한다. WallpaperControllerImpl 객체는 Shell 객체에 대하여 자기 자신을 옵저버로 등록한다. 또한, WindowTreeHostManager 객체에 대해서도 자기 자신을 옵저버로 등록한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WallpaperControllerImpl::WallpaperControllerImpl(PrefService* local_state) {
...
Shell::Get()-&amp;gt;window_tree_host_manager()-&amp;gt;AddObserver(this);
Shell::Get()-&amp;gt;AddShellObserver(this);
...
}

void Shell::AddShellObserver(ShellObserver* observer) {
shell_observers_.AddObserver(observer);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결국, &lt;strong&gt;&lt;em&gt;언젠가&lt;/em&gt;&lt;/strong&gt; Shell 객체의 OnRootWindowAdded 메서드가 호출되면 아래와 같은 콜 플로우로
CreateWallpaperWidget 메서드를 통해 배경화면을 품는 Widget 객체가 생성된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Shell::OnRootWindowAdded(aura::Window* root_window);
void WallpaperControllerImpl::OnRootWindowAdded(...);
void WallpaperControllerImpl::InstallDesktopController(...);
views::Widget* CreateWallpaperWidget(...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Shell 객체와 WallpaperController 객체는 싱글턴 패턴이 적용된 싱글턴 객체이다. 그리고 두 객체는 옵저버 패턴으로 관계를 맺고, 이 관계에서 Shell 객체는 &lt;strong&gt;&lt;em&gt;관찰 대상&lt;/em&gt;&lt;/strong&gt;, WallpaperController 객체는 &lt;strong&gt;&lt;em&gt;옵저버&lt;/em&gt;&lt;/strong&gt;임을 알 수 있다.&lt;/p&gt;

&lt;p&gt;옵저버인 WallpaperController 객체의 OnRootWindowAdded 메서드는 관찰 대상인 Shell 객체로부터 무언가 변경 사항이 있었음을 통지받는 수단으로 호출된다.
메서드의 이름으로 미루어 변경 사항이란 “RootWindow가 생성되어 어느 리스트? 배열?에 추가될 때” 이다.&lt;/p&gt;

&lt;p&gt;그런데 이상한 점은,
옵저버가 변경 사항을 통지받는 OnRootWindowAdded 메서드는 동일한 이름의 관찰 대상의 메서드라는 점이다. 여기서 코드를 보지 않고 유추해 볼 수 있는 건,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Shell 클래스와 WallpaperController 클래스는 동일한 클래스를 상속받고 있을 수 있다는 것. 실제로 두 클래스는 ShellObserver 클래스의 자식 클래스이다. 심지어, non-primary root window?가 생성되었음을 관찰 대상이 옵저버로 통지한다는 사실을 주석을 통해서 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ASH_EXPORT ShellObserver {
public:
...
// Invoked after a non-primary root window is created.
virtual void OnRootWindowAdded(aura::Window* root_window) { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Shell 객체는 WallpaperController 객체의 관찰 대상이면서 또 다른 어떤 객체에 대한 옵저버일 수 있다는 것. 실제로 Shell 객체는 RootWindowController 객체에 대한 옵저버이다. Shell 객체는 싱글턴 객체이므로 굳이 옵저버 배열을 사용하지 않고 직접적으로 변경 사항을 통지하고 있다. 판단문을 통해 PRIMARY 타입이 아닌 RootWindow 생성 시에만 통지하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void RootWindowController::Init(RootWindowType root_window_type) {
...
if (root_window_type == RootWindowType::PRIMARY) {
...
} else {
// Notify shell observers about new root window.
shell-&amp;gt;OnRootWindowAdded(root_window);
}
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 03 Aug 2019 00:21:14 +0900</pubDate>
        <link>http://baek9.github.io/chrome%20os/2019/08/03/Ash-part-1.html</link>
        <guid isPermaLink="true">http://baek9.github.io/chrome%20os/2019/08/03/Ash-part-1.html</guid>
        
        <category>tips</category>
        
        
        <category>Chrome OS</category>
        
      </item>
    
      <item>
        <title>크롬OS 개발 및 디버깅 팁</title>
        <description>&lt;p&gt;본 포스트에서는 크롬OS를 사용하면서 익힌 팁들을 기록한다.&lt;/p&gt;

&lt;h2 id=&quot;virtual-console&quot;&gt;Virtual console&lt;/h2&gt;

&lt;p&gt;크롬 브라우저에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl + Alt + T&lt;/code&gt;를 누르면 Crosh(Chrome shell)이 뜨고, Crosh 프롬프트에서 “shell”이라고 치면 심지어 bash 쉘이 실행된다. 그러나, 크롬 브라우저에서는 가끔 출력이 불완전한 경우가 많아서 가상 터미널로 진입하는 것이 편했다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl + Alt + F3&lt;/code&gt;을 누르면 가상 터미널 화면으로 이동한다. 일반 리눅스에서와 마찬가지로 접속과 동시에 아이디를 입력해야 하는데, 기본 아이디는 “chronos”이고 비밀번호는 “chrome”이다. 이 비밀번호는 크로미움OS 컴파일 시에 수동으로 설정할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;partitions&quot;&gt;Partitions&lt;/h2&gt;

&lt;p&gt;일반적으로 리눅스에서는 보통 swap과 / 파티션이 기본으로 설정된다. 크롬OS는 상당히 복잡한 형태로 파티션을 구성하는데 이 구성은 바꿀 수 없다. 크롬은 home, boot, kernel, / 각각에 대해 별도의 파티션을 구성한다. 이 때, kernel 및 / 파티션은 A/B 업데이트와 비상용으로 2쌍의 파티션을 더 생성한다. 이렇게 크롬OS 구동에 필수적으로 필요한 파티션은 총 8개로 보이며, 기타 자잘한 파티션들까지 합쳐 총 12개의 파티션이 디스크에 자동으로 설정된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mount&lt;/code&gt; 명령어로 파티션의 설정을 확인해보면 파티션마다 설정이 다름을 알 수 있다. 예를 들어, / 파티션은 읽기는 가능하지만 쓰기가 불가능하고, home 파티션은 읽고 쓰기가 가능하지만 실행이 불가능하다. 이런 식으로 보안 상 크롬OS는 파티션을 세분화하여 각 파티션의 필요로하는 최소의 권한만 부여하고 있다. 그러나, / 파티션에 쓰기가 불가능한 점은 개발이나 디버깅 시에 불편하다. 다음의 명령어로 간단하게 쓰기가 가능하도록 마운트가 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;mount &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; remount,rw /
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;chrome-os-session&quot;&gt;Chrome OS session&lt;/h2&gt;

&lt;p&gt;크롬OS는 session_manager라는 프로세스에서 시작된다. 따라서 session_manager 프로세스를 강제 종료하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl + Alt + F1&lt;/code&gt;을 눌러도 크롬OS가 뜨지 않는다. 아래와 같은 명령어로 크롬OS를 복구할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;session_manager
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;daemons&quot;&gt;Daemons&lt;/h2&gt;

&lt;p&gt;크롬OS를 구성하는 대부분의 서비스들이 데몬 형태로 동작하며, 대부분 minijail로 샌드박싱되어 동작한다. minijail은 컨테이너 + virtio 기능을 활용하는 샌드박싱 프로그램이다. 이름처럼 작지만 기능은 결코 작지 않다. 크롬OS에서 구동되는 리눅스용 어플리케이션들 역시 이 minijail안에서, 그리고 데비안 루트 파일시스템을 기반으로 동작한다.&lt;/p&gt;
</description>
        <pubDate>Sat, 03 Aug 2019 00:21:14 +0900</pubDate>
        <link>http://baek9.github.io/chrome%20os/2019/08/03/%ED%81%AC%EB%A1%ACOS_%EA%B0%9C%EB%B0%9C_%EB%B0%8F_%EB%94%94%EB%B2%84%EA%B9%85_%ED%8C%81.html</link>
        <guid isPermaLink="true">http://baek9.github.io/chrome%20os/2019/08/03/%ED%81%AC%EB%A1%ACOS_%EA%B0%9C%EB%B0%9C_%EB%B0%8F_%EB%94%94%EB%B2%84%EA%B9%85_%ED%8C%81.html</guid>
        
        <category>tips</category>
        
        
        <category>Chrome OS</category>
        
      </item>
    
      <item>
        <title>https의 원리, 그리고 Self-signed SSL 까지</title>
        <description>&lt;p&gt;크로미움 분석으로 알게 된 사실 중 한 가지는 http보다 https로 접속한 웹 페이지에서 더 많은 자바스크립트 메소드를 사용할 수 있다는 것이다. 즉, 크롬은 스킴(scheme)에 따라 차등화된 권한을 웹 페이지에 부여한다. ”http://“, ”https://“, “chrome://“ 순으로 더 강력한? 메소드를 호출할 수 있다. chrome 스킴이야 당연히 크롬의 설정 페이지(chrome://settings)처럼 크롬의 운영과 관련된 부분들을 다루므로 기능적으로나 보안적으로나 다른 스킴들과는 다르긴 하겠지…라며 쉽게 납득했지만, http와 https 스킴의 권한이 다른 것에는 꽤 놀랐었다.&lt;/p&gt;

&lt;p&gt;크롬이 http 스킴의 웹 페이지에 대해서 안전하지 않다고 경고하기 시작한 후부터 https 스킴이 아닌 웹 사이트를 찾아보기 힘들다. 그런데 웹 개발자 입장에서는 https로 개발 중인 웹 사이트를 테스트하는 것이 번거롭다. 웹 사이트가 안전한 사이트라고 증명해주는 인증서(certificate)를 구매하여야 하기 때문이다. 본 포스트 작성에 참고한 사이트들을 보면서 좀 더 쉽게 테스트 하고자 하는 개발자들이 이미 수두룩 했음을 알 수 있었다.&lt;/p&gt;

&lt;p&gt;만약, localhost를 https로 접속할 수 있다면 얼마나 좋을까하는 생각을 했다. 나는 웹 개발에도 관심은 있지만 그보다 자바스크립트 엔진 쪽에 관심이 있어서 찾아보기 시작했는데 이미 훌륭한 시행착오들이 있었다. 그냥 그대로 따라하면 되는 부분들이다. 하지만 인증서를 비롯한 https의 전반적인 원리가 궁금하여 함께 따로 정리해 보았다. 참고로, 자바스크립트 엔진은 https에 대하여 ‘secure context’에서 구동되어 더 많은 권한의 메소드들의 호출을 허락한다. 아래 웹 페이지를 참고.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;httpshttp-over-ssl&quot;&gt;HTTPS(HTTP over SSL)&lt;/h2&gt;

&lt;p&gt;의문 한 가지. 크롬은 http 스킴의 웹 페이지를 접속하면 안전하지 않은 사이트라고 경고한다. 즉, https 스킴의 웹 페이지는 안전하다는 것인데 안전하다는 것을 크롬은 어떻게 알 수 있는 것인가? 바로 절대적으로 신뢰할 수 있는 제3자를 통해 알 수 있는 것이다. 이 때 사용되는 것이 인증서이다. 전체적인 메커니즘을 이해하기 위해서는 먼저 ‘비대칭 암호화’(Asymmetric Cryptography), ‘전자서명’(Digital Signature)에 대하여 알아야 했다.&lt;/p&gt;

&lt;h2 id=&quot;비대칭-암호화-공개키-암호화&quot;&gt;비대칭 암호화(= 공개키 암호화)&lt;/h2&gt;

&lt;p&gt;대칭키 암호화에서는 데이터를 암호화하거나 복호화하는데 사용되는 키가 동일하다. 대칭키 암호화의 단점은 키가 유출되면 데이터도 유출된다는 점이다. 이 때문에 혼자만 키를 간직하는 파일 압축, 윈도우의 볼륨 암호 기능인 비트락커(BitLocker) 등에서 사용된다. 만약, 두 사람이 “안전한” 암호 통신을 하고 싶다면? 이 경우에 비대칭 암호화가 활용된다. 비대칭 암호화에서는 암호화할 때 쓰는 키와 복호화할 때 쓰는 키가 다르다. 쌍을 이루는 두 키, A와 B가 있을 때, A키로 암호화하면 B키로 복호화되고, B키로 암호화하면 A키로 복호화된다. 본 포스트는 비대칭 암호화에 대한 수학적인 내용은 담지 않았다.&lt;/p&gt;

&lt;h2 id=&quot;공개키-서명-공개키-검증&quot;&gt;공개키 서명, 공개키 검증&lt;/h2&gt;

&lt;p&gt;과연 비대칭 암호화는 어디에 쓸모 있는 걸까? 앞서 말했듯이 두 사람 간의 암호 통신에 사용될 수 있다. 이를 위해서 키 쌍 중 하나를 비밀키(private key), 다른 하나를 공개키(public key)로 지정한다. 비밀키는 절대 공개되어서는 안되며, 공개키는 공개되어도 무방하다. 아니, 오히려 공개되어야 의미가 있다. 키를 공개한다고? 이 특이한 특징 때문에 비대칭 암호화를 “공개키 암호화”라고도 부른다. 공개키 암호화는 크게 두 부분으로 동작한다. 바로 ‘공개키 서명’과 ‘공개키 검증’이 바로 그것이다. 먼저, 공개키 서명은 다음의 절차로 이루어진다.&lt;/p&gt;

&lt;h4 id=&quot;공개키-서명&quot;&gt;공개키 서명&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;철수 : 데이터 원문과 원문을 비밀키로 암호화한 암호문을 함께 송신.&lt;/li&gt;
  &lt;li&gt;영희 : 원문과 암호문를 수신하여 원문과 공개키로 복호화한 복호문을 비교.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;영희는 복호문과 원문이 일치할 때 데이터를 보낸 사람이 철수임을 확신할 수 있다. 이 때 철수가 보낸 암호문은 공개키를 가지고 있는 누구라도 복호화 될 수 있다. 이 과정이 인감을 이용한 진본 확인, 신원 확인 절차와 동일하기 때문에 “서명”이라고 불린다.&lt;/p&gt;

&lt;p&gt;그리고 공개키 암호는 다음의 절차로 이루어진다.&lt;/p&gt;

&lt;h4 id=&quot;공개키-암호&quot;&gt;공개키 암호&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;영희 : 데이터 원문을 공개키로 암호화한 암호문을 송신.&lt;/li&gt;
  &lt;li&gt;철수 : 암호문을 수신하여 비밀키로 복호화.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;앞의 공개키 서명 과정과 비교하면 철수는 비공개키를 이용하여 영희가 공개키로 암호화한 암호문을 복호화할 수 있다. 다만, 비밀키는 말그대로 철수만 갖고 있으므로 철수 외 그 누구도 암호문을 복호화할 수 없다. &lt;u&gt;즉, 두 사람은 서로의 공개키를 교환함으로써 서로의 신원을 확신하고, 서로의 공개키로 데이터를 암호화하여 보냄으로써 상호 간에 안전하게 데이터를 주고 받을 수 있다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;공개키 암호만을 이용한 전자 통신은 성능이 떨어진다고 알려져 있다. 개인적인 생각으로 다자간 암호 통신 시에는 송신할 데이터를 모든 수신자들의 공개키로 각각 암호화해야하고, 각 수신자들에게 개별적으로 송신해야 할 것 이므로 매우 불편할 것이다. 실제로 공개키 암호화는 대칭키를 공유하기 위한 용도로만 사용하며 그 대칭키를 이용하여 실제 통신이 이루어진다.&lt;/p&gt;

&lt;h2 id=&quot;공개키-기반-구조pki--public-key-infrastructure&quot;&gt;공개키 기반 구조(PKI : Public Key Infrastructure)&lt;/h2&gt;

&lt;p&gt;단순히 공개키 암호화만 알아서 암호 통신은 불가능하다. ‘공개키 기반 구조’는 공개키 암호화를 기반으로 한 암호 통신에 필요한 모든 요소들을 포함하는 용어이다. 여기에는 이후에 설명할 인증서(Certificate)와 인증기관(CA : Certificate Authority)에 대한 내용이 포함된다.&lt;/p&gt;

&lt;h2 id=&quot;sslsecure-sockets-layer&quot;&gt;SSL(Secure Sockets Layer)&lt;/h2&gt;

&lt;p&gt;웹이 발전하면서 웹을 통한 안전한 통신이 요구되었다. 왜냐면 사용자가 보는 웹 페이지가 변조되었는지 여부를 판단해야 했기에. 이를 위해 일찍이 넷스케이프(Netscape)사는 PKI 구조에 따라 ‘SSL’을 개발하였다. 이후, 표준으로 제정되면서 TLS(Transport Layer Security)라는 이름으로 변경되었다. https는 이 SSL 위에서 동작하는 웹 프로토콜이다.&lt;/p&gt;

&lt;h2 id=&quot;https의-전체적인-동작-과정&quot;&gt;HTTPS의 전체적인 동작 과정&lt;/h2&gt;

&lt;p&gt;https 프로토콜의 동작은 다음과 같다. 앞서 공개키 서명에서는 송신자가 데이터의 원본과 원본을 비밀키로 암호화한 암호문을 보내면 수신자는 공개키로 암호문을 복호화한 복호문과 원문의 일치 여부로 송신자의 신원을 검증할 수 있다. 이 때, 암호문을 “송신자의 서명”이라고 한다. 이와 비슷하게 https 프로토콜에서 데이터의 원본에는 사용자가 접속하고자 하는 ‘서버의 도메인’과 ‘서버 공개키’가 들어있다. 데이터의 원본과 ‘서버 서명’을 묶어 ‘인증서’(certificate)라고 부른다.(실제로는 서버 서명이 아니라 CA 서명이 들어 있지만 설명을 위해서 가정헤보면) 어? 그런데 서버 공개키가 인증서에 들어간다? 앞서 살펴본 공개키 서명에서는 수신자가 송신자의 공개키를 이미 알고 있다고 가정한 부분이 깨진다. 이는 심각한 보안 상 결함으로 이어진다. 예를 들어 “https://www.google.com”에 접속한 사용자가 구글 서버로부터 구글 서버의 공개키를 포함한 인증서를 받았다. 당연히 인증서에 포함된 공개키로 해당 인증서는 검증이 될 것이다. 문제는 구글 서버가 진짜 구글 서버가 맞느냐는 것이다. 만약, 사용자가 주소를 잘못 쳐서 접속한 “googlee.com”이 마침 악의적인 의도를 가지고 “google.com”을 사칭하고 있는 상황이라면?&lt;/p&gt;

&lt;h2 id=&quot;인증기관ca--certificate-authority&quot;&gt;인증기관(CA : Certificate Authority)&lt;/h2&gt;

&lt;p&gt;결국, 구글 서버로부터 받은 것으로 추측되는 인증서가 신뢰가능한 지를 검증해야만 한다. 그렇지 않으면 우리는 미국 산호세에 있는 구글 본사에 직접 가서 구글 서버의 공개키를 받아야만 한다. 마찬가지로 네이버를 이용하려면 분당에 있는 네이버 본사에 직접 가서 공개키를 받아야만 한다. 하지만, 그럴 수 없으니 제3자를 통해서 인증서를 검증하는 부분이 PKI에 포함되어 있다.이 제3자를 ‘인증기관’(CA : Certificate Authority)이라고 한다. CA의 역할은 사용자가 접속한 서버의 인증서를 신뢰할 수 있는지를 대신 검증해주는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;인증서-체인certificate-chain&quot;&gt;인증서 체인(Certificate Chain)&lt;/h2&gt;

&lt;p&gt;다시, 사용자가 “https://www.google.com”에 접속하는 시나리오에서 사용자는 구글 서버로부터 인증서를 전달받을 것이다. 이 인증서에는 ‘서버 도메인’, ‘서버 공개키’ 뿐만 아니라 ‘CA 도메인’, 그리고 서버가 아닌 ‘CA 서명’이 들어있다. 이 인증서를 검증하려면 서명이 CA의 것이기 때문에 CA의 공개키가 필요하다. 이 때, 인증서의 서명이 검증되었다는 의미는 다음과 같이 연쇄 해석이 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인증서의 서명이 검증되었다&lt;/li&gt;
  &lt;li&gt;== 인증서는 CA에 의해 서명된 진본이다&lt;/li&gt;
  &lt;li&gt;== 인증서를 보낸 서버는 믿을 수 있다&lt;/li&gt;
  &lt;li&gt;== &lt;u&gt;인증서에 포함된 공개키는 서버의 것이 맞다&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면 CA의 공개키는 도대체 어디에 있는가? 바로 운영체제와 크롬 브라우저가 미리 포함하고 있는 ‘CA 인증서’에 있다. 결국, CA 인증서로 서버 인증서를 검증하는 모양새이다. 이를 ‘인증서 체인’이라고 한다. CA 자체는 어찌할 수 없이 신뢰할 수 밖에 없다. 이 때문에 크랙된 운영체제나 웹 브라우저를 쓰는 등 믿을 수 없는 소스로부터 받은 소프트웨어를 사용하는 것은 보안 상 좋지 않다.&lt;/p&gt;

&lt;h2 id=&quot;self-signed-ssl&quot;&gt;Self-signed SSL&lt;/h2&gt;

&lt;p&gt;위와 같은 복잡한 PKI 구조 때문에 https로 서비스되는 웹 사이트를 미리 테스트하는 것은 쉽지 않다. 테스트 하고자 하는 웹 사이트의 도메인과 서버 공개키를 CA에 보내어 서버 인증서를 발급받아야 하기 때문이다. 다시 한 번 정리하면 이 인증서에는 다음의 내용이 포함되어 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서버 도메인&lt;/li&gt;
  &lt;li&gt;서버 공개키&lt;/li&gt;
  &lt;li&gt;CA 도메인&lt;/li&gt;
  &lt;li&gt;CA 서명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결국 웹 사이트 개발자 입장에서 겨우 테스트용 웹 사이트를 위해 CA로부터 인증서를 발급받아야 하는 상황이다.(어차피, 엄격한 CA는 테스트 용도의 웹 사이트를 위해 인증서를 발급해 줄 것 같지 않다)&lt;/p&gt;

&lt;p&gt;만약, 내가 직접 CA의 역할을 할 수 있다면 얼마나 좋을까. 이미 Self Signed SSL이라는 키워드로 검색하면 많은 글들이 쏟아져 나온다. 그 중에서도 localhost에 대한 인증서를 스스로 직접 서명하는 과정을 소개하려고 한다.&lt;/p&gt;

&lt;h4 id=&quot;1-ca측-ca-비밀키-생성&quot;&gt;1. (CA측) CA 비밀키 생성&lt;/h4&gt;

&lt;p&gt;CA(root CA)의 역할을 하기 위해서는 CA로서의 비밀키와 공개키를 생성해야 한다. 아래 명령어는 OpenSSL이라는 프로그램을 이용하여 대표적인 공개키 암호 알고리즘인 RSA(Rivest–Shamir–Adleman)로 길이가 2048 비트인 비밀키를 생성하여 rootCA.key에 저장한다. des3 옵션은 비밀키를 대칭키 알고리즘인 3DES(Triple Data Encryption Standard)로 한번 더 암호화하라는 의미이다. 비밀키는 절대 유출되어서는 안되기 때문에 한번 더 보호하기 위함이며, 아래 명령어를 입력하는 즉시 암호키를 요구할 것이다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;openssl genrsa &lt;span class=&quot;nt&quot;&gt;-des3&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-out&lt;/span&gt; rootCA.key 2048
// rootCA.key 생성됨
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2-ca측-ca-인증서-생성&quot;&gt;2. (CA측) CA 인증서 생성&lt;/h4&gt;

&lt;p&gt;아래 명령어를 통하여 CA용 비밀키와 쌍을 이루는 CA용 공개키를 생성하고, 그 공개키와 CA의 기본 정보에 대해 CA 비밀키로 서명한 CA 인증서를 생성한다. 이렇게 생성된 CA 인증서는 웹 브라우저 또는 운영체제에 신뢰할 수 있는 인증서로 등록할 것이다. 추후, 로컬 웹 서버로부터 받는 서버 인증서의 신뢰 여부는 이 CA 인증서를 이용하여 판단된다. x509 옵션은 X.509 포맷의 인증서를 생성하겠다는 의미이고, nodes(node의 복수형이 아니다…) 옵션은 CA용 공개키를 암호화하지 않겠다는 의미이다. sha256 옵션은 서명 생성에 SHA256 해시 알고리즘을 사용하겠다는 의미이다. 사실, &lt;u&gt;서명 생성 시에 데이터를 그대로 비밀키로 암호화하는 것이 아니라 데이터를 해시값으로 가공한 것을 비밀키로 암호화한다.&lt;/u&gt; days 옵션은 인증서의 유효기간을 설정하는 것이다. 이 명령어는 1,024일간 유효한 인증서를 생성한다. 결국 rootCA.crt라는 CA 인증서가 생성된다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;openssl req &lt;span class=&quot;nt&quot;&gt;-x509&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-new&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-nodes&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-key&lt;/span&gt; rootCA.key &lt;span class=&quot;nt&quot;&gt;-sha256&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-days&lt;/span&gt; 1024 &lt;span class=&quot;nt&quot;&gt;-out&lt;/span&gt; rootCA.crt
// rootCA.crt 생성됨
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어를 치면 CA 공개키 생성 및 CA 서명 생성에 CA 개인키를 쓰기 위하여 암호를 물어볼 것이다. 이 암호는 앞서 CA 개인키를 DES3로 암호화할 때 쓴 대칭키를 입력하면 된다. 이어 CA로서의 기본적인 정보를 몇 가지 물어볼 것이다. 이를 테면 CA의 국적이라던지 이름, 도메인 등의 정보들이다.&lt;/p&gt;

&lt;h4 id=&quot;3-서버측-서버-비밀키-생성생략-가능&quot;&gt;3. (서버측) 서버 비밀키 생성(생략 가능)&lt;/h4&gt;

&lt;p&gt;이제 서버 비밀키를 생성할 차례이다. CA 비밀키를 생성했던 방법과 동일하게 아래처럼 입력하면 된다. des3 옵션이 없는데 des3 옵션은 기본 옵션이다. 일단, 서버 비밀키를 지금 생성하지 않고 다음 과정에서 생성할 것이다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;openssl genrsa &lt;span class=&quot;nt&quot;&gt;-out&lt;/span&gt; server.key 2048 
// server.key 생성됨
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4-서버측-서버-비밀키공개키-및-csr-생성&quot;&gt;4. (서버측) 서버 비밀키/공개키 및 CSR 생성&lt;/h4&gt;

&lt;p&gt;통상적으로 웹 개발자는 서버 도메인과 서버 공개키를 CA에 보내어 CA 개인키로 서명이 된 서버 인증서를 발급하여 달라는 요청을 하여야 한다. 이 요청을 CSR(Certificate Signing Request)이라고 한다. CSR 생성에 필요한 정보들은 별도의 파일에 작성하여 OpenSSL에 제공할 수 있다. 아래 server.csr.cnf를 보면 “[dn]” 항목에 서버의 정보를 적게 되어 있다. 이 때, CN 필드를 정확히 입력해야 한다. 아무리 CA의 서명을 받은 서버 인증서라도 사용자가 접속하려는 사이트의 도메인이 CN 필드에 기재된 도메인에 포함되지 않으면 브라우저는 접속을 차단한다. 차단되는 이유는 CSR 작성 시에 오타가 발생했거나, CA의 비밀키가 유출되어 엉뚱한 사이트에 대해 인증서가 잘못 발급된 경우를 의심해 볼 수 있다. 두 경우 모두 심각한 보안 사고로 이어진다. 디지노타라는 CA는 비밀키가 유출되어 파산에 이르렀다고 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# server.csr.cnf (for creating csr)
[req]
default_bits = 2048
prompt = no
default_md = sha256
distinguished_name = dn

[dn]
C=US
ST=RandomState
L=RandomCity
O=RandomOrganization
OU=RandomOrganizationUnit
emailAddress=hello@example.com
CN = localhost
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 명령어는 위에서 작성한 server.csr.cnf에 기재된 서버 정보를 바탕으로 server.csr이라는 CSR을 생성한다. 이 때, newkey 옵션으로 생성한 서버 개인키도 활용한다. CSR 생성 시에 서버 공개키가 포함된다고 설명했는데, 사실, OpenSSL이 비밀키를 생성할 적에는 비밀키 뿐만 아니라 공개키도 이미 포함을 하고 있다. 이에 대해서는 아래에 추가로 설명한다. 어쨋든 이렇게 만들어진 CSR은 서버 비밀키로 서명된다. 결국, 서버 비밀키인 server.key와 CSR인 server.csr이 생성된다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;openssl req &lt;span class=&quot;nt&quot;&gt;-new&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-sha256&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-nodes&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-out&lt;/span&gt; server.csr &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-newkey&lt;/span&gt; rsa:2048 &lt;span class=&quot;nt&quot;&gt;-keyout&lt;/span&gt; server.key &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-config&lt;/span&gt; &amp;lt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;server.csr.cnf &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 // server.key, server.csr 생성됨
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;5-ca측-서버-인증서-생성&quot;&gt;5. (CA측) 서버 인증서 생성&lt;/h4&gt;

&lt;p&gt;CA 입장에서는 서버로부터 받은 CSR을 CA 개인키로 서명한 서버 인증서를 서버에 보내주어야 한다. 인증서 생성에는 확장 필드를 추가할 수 있다. 아래의 v3.ext 파일을 보면 인증서의 포맷인 X.509의 표준의 세 번째 확장에 대한 내용이 담겨있다. 이 확장에는 하나의 인증서로 여러 도메인을 신뢰하게 해 줄 수 있는 SAN(Subject Alternative Name) 필드 등이 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# v3.ext(for creating X509 v3 certificate)
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 명령어는 앞서 생성한 CSR인 server.csr에 앞서 작성한 v3.ext에 담긴 X.509 확장 필드를 붙여 서버 인증서를 생성한다. 이 인증서는 CA 개인키인 rootCA.key로 서명된다. 결국, server.crt라는 서버 인증서가 만들어진다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-script&quot;&gt;$ openssl x509 -req -in server.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial \
-out server.crt -days 500 -sha256 -extfile v3.ext
// server.crt 생성됨
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;-비밀키공개키의-생성&quot;&gt;+. 비밀키/공개키의 생성&lt;/h4&gt;

&lt;p&gt;위 과정을 따라하면서 궁금했던 점은 비밀키와 공개키는 한 쌍임에도 불구하고 명시적으로 공개키를 생성하는 과정이 없었다는 점이다. 비밀키에 공개키가 포함되어 있는 것이 아닌가 의심 되었지만 OpenSSL의 genrsa 명령어는 비밀키를 생성한다고만 되어있었다. 실제로 genrsa로 생성되는 것은 비밀키와 공개키 생성에 필요한 여러가지 팩터들이고, 이들을 이용하여 필요할 때마다 빠르게 비밀키와 공개키를 생성한다고 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/44350448&quot;&gt;https://stackoverflow.com/a/44350448&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Apr 2019 07:21:14 +0900</pubDate>
        <link>http://baek9.github.io/security/2019/04/10/https%EC%9D%98_%EC%9B%90%EB%A6%AC,_%EA%B7%B8%EB%A6%AC%EA%B3%A0_Self-signed-SSL_%EA%B9%8C%EC%A7%80.html</link>
        <guid isPermaLink="true">http://baek9.github.io/security/2019/04/10/https%EC%9D%98_%EC%9B%90%EB%A6%AC,_%EA%B7%B8%EB%A6%AC%EA%B3%A0_Self-signed-SSL_%EA%B9%8C%EC%A7%80.html</guid>
        
        <category>https</category>
        
        <category>SSL</category>
        
        <category>PKI</category>
        
        
        <category>Security</category>
        
      </item>
    
      <item>
        <title>Integer Overflow in V8</title>
        <description>&lt;p&gt;최근 취약점들을 살펴보면 순수하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;V8&lt;/code&gt;과 관련된 취약점은 별로 없고, 그나마 JavaScript로 시작하되 최종적으로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Blink&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chrome&lt;/code&gt;에서 취약점이 발생하는 경우들이 많은 것 같다. 와중에 최근에 등록된 버그가 눈길을 끌었다. &lt;code class=&quot;highlighter-rouge&quot;&gt;V8&lt;/code&gt; 내부에서 정수 오버플로우(Integer Overflow)를 유발하는 PoC(Proof of Concept)를 제시하고 있었다. 대략적인 &lt;code class=&quot;highlighter-rouge&quot;&gt;V8&lt;/code&gt;의 구조와 정수 오버플로우가 어떤 것인지 알게된 의미있는 분석이었다.&lt;/p&gt;

&lt;h2 id=&quot;regexpprototypereplace&quot;&gt;RegExp.prototype[@@replace]&lt;/h2&gt;

&lt;p&gt;해당 PoC는 결국에 C++ 함수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime_RegExpReplace()&lt;/code&gt;에서 발현된다.(이하 RegExpReplace) 이 함수는 자바스크립트 레벨에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp.prototype[@@replace]&lt;/code&gt; 메소드(이하 replace)에 대응되는 함수이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt;는 무엇일까? 정규표현식을 표현하고 처리하기 위한 객체로 이해하면 된다. 다음 코드를 예로 들면,&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;re&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/-/g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;re는 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; 객체이다. re에 대입한 “/-/g”의 의미는 임의의 문장에서 “-“와 일치하는 모든 부분을 의미한다. 뒤에 붙은 ‘g’는 “global”의 약자로서 일치하는 부분을 모두 식별하겠다는 의미이다. 한편, MDN(Mozilla Developers Network)에서 제시하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;replace()&lt;/code&gt; 메소드의 용법과 예제는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2016-01-01'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// regexp[Symbol.replace](str, newSubStr|function)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'.'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 2016.01.01&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;replace()&lt;/code&gt; 메소드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; 객체의 메소드이다. 이 메소드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Symbol&lt;/code&gt; 타입으로 정의되어 있다. 이 타입은 최신 ECMA Script에 새로 추가된 것으로서, 잘 모르기도 하지만 본 포스트의 주제와 맞지 않으므로 생략한다. 어쨌든, &lt;code class=&quot;highlighter-rouge&quot;&gt;replace()&lt;/code&gt; 메소드는 두 개의 인자를 받는다. 첫 번째 인자는 원본 문자열이고, 두 번째 인자는 원본 문자열에서 정규표현식과 일치하는 부분을 치환하고자 하는 치환 문자열이다. 위 예에서 “2016-01-01“이라는 원본 문자열은 ‘-‘이 ‘.’으로 모두 치환된다.&lt;/p&gt;

&lt;h2 id=&quot;regexpprototypeexec&quot;&gt;RegExp.prototype.exec()&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 메소드는 원본 문자열에서 정규표현식과 일치하는 부분을 객체 형태로 반환한다. 아래 예제를 보자.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;re&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/foo/g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'___foo___foo'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;객체 result는 원본 문자열에서 주어진 정규표현식과 일치하는 부분들에 대한 정보를 담는다. 아래는 해당 객체의 내용을 출력해 본 것이다.원본 문자열인 “__&lt;em&gt;foo&lt;/em&gt;__foo”를 input 프로퍼티에, 정규표현식과 일치하는 부분 문자열인 “foo”를 0 프로퍼티에 담고 있다. 두 번 일치하지만 “foo”는 하나이므로 length가 1인 것으로 생각된다. 또, 원본 문자열에서 정규표현식과 일치하는 첫 번째 문자열이 시작하는 위치가 4이므로, index 프로퍼티에 4가 저장된 것으로 생각된다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;___foo___foo&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;__proto__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;regexputilsregexpexec&quot;&gt;RegExpUtils::RegExpExec()&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp.prototype.exec()&lt;/code&gt; 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;V8&lt;/code&gt; 내부에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpExec()&lt;/code&gt; 함수를 호출하는 것으로 생각된다. 당연한 말이지만, 정규표현식과 일치하는 부분을 찾아서 치환하기 위해서는 먼저 “찾아야” 한다. 따라서, &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpReplace()&lt;/code&gt; 함수는 ECMA Script에 기술된 대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpExec()&lt;/code&gt; 함수를 호출한다. 해당 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; 클래스의 객체인 result를 반환한다. 아래는 해당 객체에 대하여, &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; 클래스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Print()&lt;/code&gt; 멤버함수를 실행시킨 결과이다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mh&quot;&gt;0x24c761393899&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;JSArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3288b1786611&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;HOLEY_ELEMENTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FastProperties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x39681e485539&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;JSArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x24c7613938d1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FixedArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;HOLEY_ELEMENTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x17db08a02251&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FixedArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x17db08a4ff89&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;AccessorInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;accessor&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;descriptor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x39681e4aa699&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;___foo___foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;groups&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x17db08a022e1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x24c7613938d1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FixedArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x24c761393879&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;객체 result의 정보가 출력되는데, 이를 통해 대략 알 수 있는 것은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JSArray&lt;/code&gt; 클래스의 객체이다. (JSArray 클래스는 Object 클래스를 상속 받음)&lt;/li&gt;
  &lt;li&gt;elements와 properties라는 FixedArray 객체를 갖는다.&lt;/li&gt;
  &lt;li&gt;elements 객체의 엔트리 0에는 문자열 “foo”가 저장되어 있다.&lt;/li&gt;
  &lt;li&gt;length는 1이다. 객체 elements의 엔트리 개수를 의미한다.&lt;/li&gt;
  &lt;li&gt;properties 객체는 index, input, group이라는 엔트리를 가진다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;앞서, 자바스크립트 계층에서 result 객체를 출력한 내용과, C++ 레이어에서 result 객체를 출력한 내용이 동일한 것으로 생각된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;JSArray&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; 클래스에 대해서는 추후에 별도로 살펴보아야 할 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;flow-of-runtime_regexpreplace&quot;&gt;Flow of &lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime_RegExpReplace&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;동일한 방법으로 해당 PoC에 대하여 C++ 레이어에서 객체 result의 정보를 출력해보면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mh&quot;&gt;0x2bea81a10e31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;JS_OBJECT_TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x98850a8cf41&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;HOLEY_ELEMENTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FastProperties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x22efc2684649&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x98850a822b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7268cc02251&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FixedArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;HOLEY_ELEMENTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7268cc02251&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FixedArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unboxed&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.29497&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;09&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 PoC는 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 메소드를 임의의 함수로 대체한다. 대체한 함수는 0xfffffffe를 반환한다. 한편, 위 결과를 보면 FixedArray 객체인 properties의 엔트리 length가 double 타입의 4.29497e+09 값임을 알 수 있다. 이 값은 0xfffffffe와 동일한 값이다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 메소드가 반환하는 double 타입의 값이 length 프로퍼티에 저장된다.&lt;/p&gt;

&lt;p&gt;length는 원본 문자열에서 정규표현식과 일치하는 부분의 개수이다. 따라서, &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpReplace()&lt;/code&gt; 함수는 본연의 목적을 위해 length 만큼 루프를 돌면서 정규표현식과 일치하는 모든 부분들을 치환하여야 한다. 이러한 루프는 코드 상에서는 물론, ECMA Script 명세에서도 확인할 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpReplace()&lt;/code&gt; 함수는 객체 result의 length 프로퍼티의 값을 int 타입의 변수인 captures_length에 저장한다.&lt;/p&gt;

&lt;h2 id=&quot;integer-overflow-by-explicit-type-conversion&quot;&gt;Integer overflow by explicit type conversion&lt;/h2&gt;

&lt;p&gt;정수 오버플로우가 발현되는 부분은 이 &lt;a href=&quot;https://cs.chromium.org/chromium/src/v8/src/runtime/runtime-regexp.cc?type=cs&amp;amp;rcl=365bb5bb4a1dd62908baf0fad9d075fbcab695ed&amp;amp;l=1797&quot;&gt;link&lt;/a&gt; 부분이다. 변수 captures_length는  &lt;code class=&quot;highlighter-rouge&quot;&gt;PositiveNumberToUint32()&lt;/code&gt; 함수를 통해 객체 result의 length 프로퍼티의 값을 받는다. 함수의 이름에서부터 감이 오기 시작한다. 해당 함수는 length 프로퍼티의 값을 받아와 uint 타입으로 변환하여 반환한다. 문제는 이 반환 값을 받는 변수인 captures_length가 int 타입이라는 점이다. 결국, length 프로퍼티의 값이 4,294,967,295 값임에도 변수 captures_length의 값은 -2가 된다.&lt;/p&gt;

&lt;h2 id=&quot;crashing&quot;&gt;Crashing&lt;/h2&gt;

&lt;p&gt;이후의 코드를 따라가다 보면, int 타입의 변수 argc가 contents_length + 2로 계산이 되어 결국 0이 된다. 만약, PoC가 변조한 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 메소드를 0xfffffffd가 반환하도록 수정하면 argc의 값은 -1이 된다. 결국, 이후에 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpReplace()&lt;/code&gt; 함수는 0 이하의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Handle&amp;lt;Object&amp;gt;&lt;/code&gt; 배열을 동적할당 시도하는데, 이 과정에서 크로미움은 강제로 OOM(Out of Memory) 에러를 발생시키고 렌더러 프로세스는 종료된다.&lt;/p&gt;

</description>
        <pubDate>Tue, 03 Apr 2018 07:14:52 +0900</pubDate>
        <link>http://baek9.github.io/javascript/v8/2018/04/03/Integer_Overflow_in_RegExp_of_V8.html</link>
        <guid isPermaLink="true">http://baek9.github.io/javascript/v8/2018/04/03/Integer_Overflow_in_RegExp_of_V8.html</guid>
        
        <category>Integer Overflow</category>
        
        <category>V8</category>
        
        
        <category>JavaScript</category>
        
        <category>V8</category>
        
      </item>
    
      <item>
        <title>Playing with JSON in Chromium</title>
        <description>&lt;p&gt;다른 포스트에서도 언급했거나 언급하겠지만, 크로미움은 그 자체로 매우 풍부한 라이브러리 집합이다. 예를 들면, &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;GURL&lt;/code&gt; 클래스를 이용하면 손쉽게 스레드를 만들고 관리할 수 있으며, URL도 입맛대로 다룰 수 있다. (scheme만 따로 추출하려고 굳이 파싱하지 않아도 되는) 이 밖에도 유용한 클래스들이 많이 존재하며, 이들은 크로미움의 &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; 네임스페이스에 존재한다.&lt;/p&gt;

&lt;p&gt;크로미움은 웹 브라우저이므로 당연히 JSON(JavaScript Object Notation)을 처리하기 위한 모듈이 존재할 것이다. 아니, 존재하여야만 한다. 실제로, &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; 네임스페이스 아래에 &lt;code class=&quot;highlighter-rouge&quot;&gt;JSONReader&lt;/code&gt; 클래스가 존재한다. 물론, &lt;code class=&quot;highlighter-rouge&quot;&gt;libjson-c&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;libjsoncpp&lt;/code&gt;와 같은 라이브러리를 활용하는 옵션도 있겠지만, 크로미움 개발자라면 굳이 이를 활용할 필요가 없겠다. 본 포스트에는 크로미움 내에서 JSON을 다루는 방법을 담았다.&lt;/p&gt;

&lt;h2 id=&quot;open-and-read-file&quot;&gt;Open and read file&lt;/h2&gt;

&lt;p&gt;처리하고자 하는 대상은 파일 형태로 존재할 수도 있고, 네트워크로 받아와 바이트 스트림 형태로 존재할 수도 있다. 파일 형태도 결국은 처리를 위해서 바이트 스트림 형태로 변환해야 하므로 전자의 경우를 보겠다.&lt;/p&gt;

&lt;p&gt;크로미움은 심지어 파일 경로를 처리하는 클래스까지 갖고 있다. 해당 클래스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;FilePath&lt;/code&gt;이다. 굳이 파일 경로를 처리하는 클래스가 필요한 지 의문이 들 수 있지만, 플랫폼마다 파일 경로를 구성하는 규칙이 다르기 때문에라도 매우 유용하고 중요한, 생각보다 복잡한 클래스이다. 처리하고자 하는 파일이 test.json이고, 파일 경로가 “/path/to/file/test.json”이라면 다음과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;FilePath&lt;/code&gt; 객체를 생성할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FilePath&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/path/to/file/test.json&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드로 json_path라는 &lt;code class=&quot;highlighter-rouge&quot;&gt;FilePath&lt;/code&gt; 객체가 생성된다. 이제 이 객체를 이용하여 test.json을 읽고, 그 내용을 바이트 스트림 형태로 가져와야 한다. 이 작업은 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReadFileToString()&lt;/code&gt; 함수를 이용하여 아래와 같이 수행할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadFileToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드로 test.json의 내용이 문자열 객체인 json_string에 저장된다.&lt;/p&gt;

&lt;h2 id=&quot;parse-json-and-ready-to-play-with-it&quot;&gt;Parse JSON and Ready to play with it&lt;/h2&gt;

&lt;p&gt;json_string은 test.json의 내용을 바이트 스트림으로 저장하고 있을 뿐인 문자열 객체에 불과하다. 이 문자열을 JSON 문법에 맞추어 취급하기 쉬운 형태로 파싱하여야 한다. 생각만해도 번거로운 이 작업은 &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; 네임스페이스 내 &lt;code class=&quot;highlighter-rouge&quot;&gt;JSONReader&lt;/code&gt; 클래스의 멤버 함수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Read()&lt;/code&gt;로 쉽게 처리할 수 있다. static 함수이므로 다음과 같이 활용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json_structure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;json_structure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSONReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드로 json_structure라는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt; 객체가 생성된다. 이를 이용하여 test.json 내의 모든 키 값들을 추출할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;getting-a-dictionary-from-a-json&quot;&gt;Getting a dictionary from a JSON&lt;/h2&gt;

&lt;p&gt;JSON은 다음의 두 개의 구조를 바탕으로 구성된다. &lt;a href=&quot;https://www.json.org&quot;&gt;JSON 공식 홈페이지&lt;/a&gt;에 두 구조에 대한 간략한 설명이 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Collection
    &lt;ul&gt;
      &lt;li&gt;name/value pairs. In various languages this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Ordered list of values
    &lt;ul&gt;
      &lt;li&gt;realized as an array, vector, list, or sequence.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JSON은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ordered list&lt;/code&gt;로 구성된다. 따라서, JSON으로부터 이 두 구조를 얻어낼 수 있다는 것은 곧, JSON을 완벽하게 활용할 수 있다는 것이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ordered list&lt;/code&gt;를 구현하는 방법은 언어에 따라 다르다. 크로미움에서는 각각 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;로 표현한다. 그리고, &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; 네임스페이스에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt; 클래스를 상속받는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;ListValue&lt;/code&gt;라는 클래스가 존재한다. 뭔가 감이 오기 시작한다. 더 진행하기에 앞서서, test.json의 내용이 다음과 같다고 가정하자.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;key1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;key11&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;value11&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;key12&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;element121&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;element122&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JSON 전쳬가 하나의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;, 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;이다. 따라서 앞서 파싱하여 얻어낸 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt; 객체인 json_structure로부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 객체를 얻어내야 한다. 그래야만 key11의 값인 “value11”과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ordered list&lt;/code&gt;인 key12가 포함하는 값들인 “element121”, “element122”를 추출할 수 있을 것이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 객체를 얻어내기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 클래스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;From()&lt;/code&gt; 함수를 이용하면 된다. static 함수이므로 다음과 같이 활용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DictionaryValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json_dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;json_dictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DictionaryValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;From&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_structure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드로 json_dictionary라는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 객체를 얻어낼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;getting-a-value-which-type-is-string-from-a-dictionary&quot;&gt;Getting a value which type is “string” from a dictionary&lt;/h2&gt;

&lt;p&gt;크로미움에서만 그런지는 모르겠지만 “.”을 이용하여 특정 키의 경로를 표현할 수 있다. 예를 들어, Key11의 주소는 “key1.key11”이다. 이 경로를 이용하여 해당 키의 값을 추출할 수 있다. key11에 대응되는 값의 타입은 문자열이므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 클래스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;GetString()&lt;/code&gt; 함수를 아래와 같이 활용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key11_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;json_dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key1.key11&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key11_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;getting-a-list-from-a-dictionary&quot;&gt;Getting a list from a dictionary&lt;/h2&gt;

&lt;p&gt;key12는 대괄호로 둘러쌓인 Ordered list, 즉, List이다. 따라서 이번에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 객체로부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::string&lt;/code&gt;이 아닌, &lt;code class=&quot;highlighter-rouge&quot;&gt;ListValue&lt;/code&gt;객체를 추출해야 한다. 이를 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 클래스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;GetList()&lt;/code&gt; 함수를 아래와 같이 활용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key12_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;json_dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key1.key12&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key12_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;iterate-and-getting-a-value-which-type-is-string-from-a-list&quot;&gt;Iterate and getting a value which type is “string” from a list&lt;/h2&gt;

&lt;p&gt;앞서 얻어낸 &lt;code class=&quot;highlighter-rouge&quot;&gt;ListValue&lt;/code&gt; 객체인 key12_list의 원소들을 순회하여 Ordered list인 key12의 모든 원소들을 추출할 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ListValue&lt;/code&gt; 클래스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt; 클래스를 상속받는다. &lt;code class=&quot;highlighter-rouge&quot;&gt;ListValue&lt;/code&gt;의 경우에는 원소들이 부모 클래스인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt;가 정의하는 멤버 변수, &lt;code class=&quot;highlighter-rouge&quot;&gt;ListStorage&lt;/code&gt;에 저장된다. 아래와 같은 연쇄 대입 체인에 따르면,&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// base/values.h
// https://cs.chromium.org/chromium/src/base/values.h?rcl=029daddc376494ee36c5d81cc51a5ade45002fb6&amp;amp;l=589
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ListValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;const_iterator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ListStorage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// base/values.h
// https://cs.chromium.org/chromium/src/base/values.h?rcl=029daddc376494ee36c5d81cc51a5ade45002fb6&amp;amp;l=85
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListStorage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ListStorage&lt;/code&gt;는 결국 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt; 객체이다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt; 객체를 순회하는 방법을 그대로 활용하여 원소들을 순회할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ListValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const_iterator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const_iterator&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;순회 중에 방문한 원소들의 타입은 무엇일까? 타입을 알아야 값을 추출할 수 있다. 위 등식에서도 알 수 있듯이, &lt;code class=&quot;highlighter-rouge&quot;&gt;iterator&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;const_iterator&lt;/code&gt;에 의해 참조하는 각 원소들은 base::Value* 또는 const base::Value*이다. 한편, &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt; 객체의 값은 멤버 함수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;GetString()&lt;/code&gt;으로 얻어낼 수 있다.(키 값의 타입이 문자열인 경우라면) 아래가 그 예제다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const_iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key12_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; 
     &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key12_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key12_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;full-example&quot;&gt;Full example&lt;/h2&gt;

&lt;p&gt;test.json으로부터 모든 값을 추출하는 전체 예제 코드는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FilePath&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/path/to/file/test.json&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json_structure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DictionaryValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json_dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key11_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key12_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadFileToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;json_structure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSONReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;json_dictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DictionaryValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;From&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_structure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;json_dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key1.key11&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key11_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;json_dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key1.key12&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key12_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const_iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key12_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; 
     &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key12_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key12_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 19 Mar 2018 06:50:45 +0900</pubDate>
        <link>http://baek9.github.io/chromium/json/2018/03/19/Playing_with_JSON_in_Chromium.html</link>
        <guid isPermaLink="true">http://baek9.github.io/chromium/json/2018/03/19/Playing_with_JSON_in_Chromium.html</guid>
        
        <category>Chromium</category>
        
        <category>JSON</category>
        
        
        <category>Chromium</category>
        
        <category>JSON</category>
        
      </item>
    
      <item>
        <title>VS Code를 이용한 원격 개발 환경 구성</title>
        <description>&lt;p&gt;커널 개발 시에는 빌드, 테스트, 디버깅까지 이어지는 과정이 꽤나 번거롭다. 이 때문에 QEMU와 gdb를 연동하여 개발 환경을 구축하는 것을 보았다. 그에 비할 바인지는 모르겠지만 리눅스 그래픽스 스택과 관련한 개발에서도 몇 애로점이 있었다. 귀찮더라도 최초에 개발 환경을 구축하는 것이 낫다는 것이 정신 건강에 이로움을 나중에야 깨달았다.&lt;/p&gt;

&lt;p&gt;보통, 리눅스를 이용한 개발은 가상머신에서 진행한다. 우분투 같은 배포판은 가상머신에 설치해도 가상머신 창의 크기에 따라 자동적으로 해상도가 조정된다. 하지만 GNOME이나 KDE와 같은 GUI 데스크톱 환경이 제공되지 않는 환경에서의 개발은 매우 불편하다. 가상머신 창의 크기를 키워도 800x600의 해상도로 고정되기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;putty--vs-code&quot;&gt;putty + VS Code&lt;/h2&gt;

&lt;p&gt;putty를 이용하면 호스트에서 원격으로 가상머신 상에 접속하여 개발이 가능하다. 심지어 &lt;code class=&quot;highlighter-rouge&quot;&gt;DISPLAY&lt;/code&gt; 환경변수의 값을 “:0”으로 설정하면 원격으로 리눅스 그래픽스 스택을 테스트할 수 있다! 물론, 디버깅 용도로 출력되는 메세지는 별도로 putty를 통해 확인할 수 있다는 점도 큰 장점이다. 한편, 코드 분석하기 위해서는 VS Code를 주로 사용하는데, 개발은 putty, 테스트는 가상머신, 분석은 VS Code에서 수행하니 매우 정신이 없었다. 물론, vi + ctags를 활용하면 putty에서 개발과 분석을 통합할 수 있지만 VS Code가 매우 좋은 도구라서 다른 방법을 찾기 시작했다.(&lt;del&gt;vi와 친하지 않다…&lt;/del&gt;)&lt;/p&gt;

&lt;h2 id=&quot;remote-vs-code&quot;&gt;Remote VS Code&lt;/h2&gt;

&lt;p&gt;VS Code는 Remote VS Code라는 플러그인을 제공한다. 이 플러그인은 이런거다. 우선, 가상머신에 rmate라는 바이너리와 ssh를 설치한다.(ssh는 putty를 사용하기 위해서도 필요하다) ssh를 설치했으므로 VS Code가 제공하는 쉘 상에서 역 터널링(reverse tunneling) 방법으로 가상머신에 접속한다. 이후, 쉘에서 “rmate [파일 경로]”를 입력하면 해당 파일을 VS Code에서 편집할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 20 Jan 2018 07:09:26 +0900</pubDate>
        <link>http://baek9.github.io/devtools/2018/01/20/VS_Code%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EC%9B%90%EA%B2%A9_%EA%B0%9C%EB%B0%9C_%ED%99%98%EA%B2%BD_%EA%B5%AC%EC%84%B1.html</link>
        <guid isPermaLink="true">http://baek9.github.io/devtools/2018/01/20/VS_Code%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EC%9B%90%EA%B2%A9_%EA%B0%9C%EB%B0%9C_%ED%99%98%EA%B2%BD_%EA%B5%AC%EC%84%B1.html</guid>
        
        <category>VS Code</category>
        
        <category>debugging</category>
        
        
        <category>Devtools</category>
        
      </item>
    
      <item>
        <title>그래픽 카드에 대응되는 DRM 디바이스 노드 찾기</title>
        <description>&lt;p&gt;DRM(Direct Rendering Manager)는 DRI(Direct Rendering Infrastructure)를 지원하는 그래픽 카드를 위한 디바이스 드라이버를 말한다. DRM과 DRI에 대해서는 다음 기회에 정리해야 할 것 같다. 이 노트에서는 주 그래픽 카드에 대응되는 DRM의 디바이스 노드를 찾는 방법만 정리하였다.&lt;/p&gt;

&lt;p&gt;보통은 /dev/dri/card0를 주 그래픽 카드에 대응되는 디바이스 노드라고 봐도 무방하다. 단, 그래픽 카드가 DRI를 지원하지 않는 경우 또는 복수의 그래픽 카드를 사용하는 경우를 제외하고 말이다. 따라서, 좀 더 확실한 방법으로 주 그래픽 카드를 식별할 수 있는 방법이 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;udevadm을-이용한-방법&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;udevadm&lt;/code&gt;을 이용한 방법&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;udevadm&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt;에 의해 생성된 디바이스 노드에 대응되는 장치의 속성들을 출력한다. 주 그래픽 카드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;boot_vga&lt;/code&gt; 속성의 값으로 1을 갖는다. 따라서, &lt;code class=&quot;highlighter-rouge&quot;&gt;udevadm&lt;/code&gt;으로 출력한 특정 디바이스 노드의 속성 중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;boot_vga&lt;/code&gt; 속성의 값이 1이라면, 해당 노드는 주 그래픽 카드에 대응된다. 만약, “/dev/dri/card0”에 대응되는 그래픽 카드의 속성들을 보기 위해서는 아래와 같이 명령어를 입력하면 된다. “/dev/dri/card0”는 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt; 관련 용어로 &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVNAME&lt;/code&gt;이라고 부르는 듯 하다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;udevadm info &lt;span class=&quot;nt&quot;&gt;--query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;all &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/dev/dri/card0
	
	P: /devices/pci0000:00/0000:00:0f.0/drm/card0
	N: dri/card0
	E: &lt;span class=&quot;nv&quot;&gt;DEVNAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/dev/dri/card0
	E: &lt;span class=&quot;nv&quot;&gt;DEVPATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/devices/pci0000:00/0000:00:0f.0/drm/card0
	E: &lt;span class=&quot;nv&quot;&gt;DEVTYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;drm_minor
	E: &lt;span class=&quot;nv&quot;&gt;ID_FOR_SEAT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;drm-pci-0000_00_0f_0
	E: &lt;span class=&quot;nv&quot;&gt;ID_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;pci-0000:00:0f.0
	E: &lt;span class=&quot;nv&quot;&gt;ID_PATH_TAG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;pci-0000_00_0f_0
	E: &lt;span class=&quot;nv&quot;&gt;MAJOR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;226
	E: &lt;span class=&quot;nv&quot;&gt;MINOR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
	E: &lt;span class=&quot;nv&quot;&gt;SUBSYSTEM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;drm
	E: &lt;span class=&quot;nv&quot;&gt;TAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;:master-of-seat:uaccess:seat:
	E: &lt;span class=&quot;nv&quot;&gt;USEC_INITIALIZED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8444405
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt;는 핫플러그(Hotplug) 방식으로 연결된 장치들에 대해 “/dev” 아래에 디바이스 노드들을 생성한다. 사실, &lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;sysfs&lt;/code&gt;가 제공하는 장치들의 정보를 가지고 “/dev”를 구성한다고 한다. 장치들의 정보는 “/sys” 아래에 계층적으로 제공되며, 이 경로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt; 관련 용어로 &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVPATH&lt;/code&gt;라고 한다. 위 결과를 통해서, &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVNAME&lt;/code&gt;인 “/dev/dri/card0”에 대응되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVPATH&lt;/code&gt;는 “/devices/pci0000:00/0000:00:0f.0/drm/card0”임을 알 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVPATH&lt;/code&gt;를 가지고도 아래와 같이 장치의 정보를 조회할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;udevadm info &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /sys/devices/pci0000:00/0000:00:0f.0/drm/card0
	
	Udevadm info starts with the device specified by the devpath and &lt;span class=&quot;k&quot;&gt;then
	&lt;/span&gt;walks up the chain of parent devices. It prints &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;every device
	found, all possible attributes &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the udev rules key format.
	A rule to match, can be composed by the attributes of the device
	and the attributes from one single parent device.
	
	  looking at device &lt;span class=&quot;s1&quot;&gt;'/devices/pci0000:00/0000:00:0f.0/drm/card0'&lt;/span&gt;:
	    &lt;span class=&quot;nv&quot;&gt;KERNEL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;card0&quot;&lt;/span&gt;
	    &lt;span class=&quot;nv&quot;&gt;SUBSYSTEM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;drm&quot;&lt;/span&gt;
	    &lt;span class=&quot;nv&quot;&gt;DRIVER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
	
	  looking at parent device &lt;span class=&quot;s1&quot;&gt;'/devices/pci0000:00/0000:00:0f.0'&lt;/span&gt;:
	    &lt;span class=&quot;nv&quot;&gt;KERNELS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0000:00:0f.0&quot;&lt;/span&gt;
	    &lt;span class=&quot;nv&quot;&gt;SUBSYSTEMS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pci&quot;&lt;/span&gt;
	    &lt;span class=&quot;nv&quot;&gt;DRIVERS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;vmwgfx&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;boot_vga&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;broken_parity_status&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;class&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x030000&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;consistent_dma_mask_bits&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;32&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;d3cold_allowed&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;device&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0405&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;dma_mask_bits&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;32&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;driver_override&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;(null)&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;irq&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;16&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;local_cpulist&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0-1&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;local_cpus&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;00000000,00000000,00000000,00000003&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;msi_bus&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;numa_node&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-1&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;subsystem_device&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0405&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;subsystem_vendor&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x15ad&quot;&lt;/span&gt;
	    ATTRS&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;vendor&lt;span class=&quot;o&quot;&gt;}==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x15ad&quot;&lt;/span&gt;
	
	  looking at parent device &lt;span class=&quot;s1&quot;&gt;'/devices/pci0000:00'&lt;/span&gt;:
	    &lt;span class=&quot;nv&quot;&gt;KERNELS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pci0000:00&quot;&lt;/span&gt;
	    &lt;span class=&quot;nv&quot;&gt;SUBSYSTEMS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
	    &lt;span class=&quot;nv&quot;&gt;DRIVERS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;libudev를-이용한-방법&quot;&gt;libudev를 이용한 방법&lt;/h2&gt;

&lt;p&gt;C코드에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;libudev&lt;/code&gt;를 이용하여 주 그래픽 카드에 대응되는 디바이스 노드를 찾을 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;weston&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;GNOME&lt;/code&gt;이 사용하는 컴포지터인 &lt;code class=&quot;highlighter-rouge&quot;&gt;mutter&lt;/code&gt;에 반영되어 있다. 이 부분은 1개 이상의 그래픽 카드가 장착된 경우를 고려한 것이다. 패치 전에는 “open(“/dev/dri/card0”)” 형태로 하드코딩하고 있었다. 패치는 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev_enumerate_*()&lt;/code&gt; 함수들을 이용해 “drm/card[0-9]*“에 매칭되는 디바이스 노드들을 순회하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;boot_vga&lt;/code&gt; 속성을 찾는다. 결국, 해당 속성을 갖는, 즉, 주 그래픽 카드의 정보를 담은 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev_device&lt;/code&gt; 객체(libudev가 제공하는 구조체)를 얻어낸다. 패치의 내용은 아래 링크에서 확인할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://lists.freedesktop.org/archives/wayland-devel/2012-October/006033.html&quot;&gt;https://lists.freedesktop.org/archives/wayland-devel/2012-October/006033.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mail.gnome.org/archives/commits-list/2015-September/msg01412.html&quot;&gt;https://mail.gnome.org/archives/commits-list/2015-September/msg01412.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;패치로 추가되는 함수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;find_primary_gpu()&lt;/code&gt;는 이름부터가 매우 직관적이다. 아래는 &lt;code class=&quot;highlighter-rouge&quot;&gt;weston&lt;/code&gt; 내부에서 해당 함수까지 이어지는 콜 스택의 일부이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;libweston/compositor-drm.c : find_primary_gpu&lt;/li&gt;
  &lt;li&gt;libweston/compositor-drm.c : drm_backend_create&lt;/li&gt;
  &lt;li&gt;libweston/compositor-drm.c : weston_backend_init(WL_EXPORT)&lt;/li&gt;
  &lt;li&gt;libweston/compositor.c : weston_load_module(WL_EXPORT)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;참고-weston_load_module&quot;&gt;참고, &lt;code class=&quot;highlighter-rouge&quot;&gt;weston_load_module()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;두 문자열 “name”과 “entrypoint”를 입력받는다. 우선 “name”을 이용하여 “.libs/[name]”에 위치한 라이브러리를 동적으로 로딩한다. “name”은 로딩하려는 라이브러리의 파일 이름을 말한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;weston&lt;/code&gt;은 백엔드(backend)마다 로딩할 라이브러리의 파일 이름을 하드코딩으로 매핑하고 있다. “libweston/compositor.c”의 &lt;code class=&quot;highlighter-rouge&quot;&gt;backend_map[]&lt;/code&gt;이라는 문자열 배열이 그것이다. “[drm|fbdev|headless|rdp|wayland|x11]-backend.so”가 배열에 존재하고, 배열 참조를 위한 인덱스는 “libweston/compositor.h” 의 enum 타입인 “weston_compositor_backend”를 이용한다. 즉, “backend_map[WESTON_BACKEND_DRM]”은 “drm-backend.so”라는 문자열로 매핑된다. 이 문자열이 &lt;code class=&quot;highlighter-rouge&quot;&gt;weston_load_moudle()&lt;/code&gt; 함수의 첫 번째 인자인 “name”으로 전달되는 것이다. 백엔드의 종류와 각각에 매핑되는 문자열은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;/// libweston/compositor.h
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weston_compositor_backend&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_DRM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_FBDEV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_HEADLESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_RDP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_WAYLAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_X11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
			
&lt;span class=&quot;c1&quot;&gt;// libweston/compositor.c
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backend_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_DRM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;		&lt;span class=&quot;s&quot;&gt;&quot;drm-backend.so&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_FBDEV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;fbdev-backend.so&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_HEADLESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;headless-backend.so&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_RDP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;		&lt;span class=&quot;s&quot;&gt;&quot;rdp-backend.so&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_WAYLAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;wayland-backend.so&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WESTON_BACKEND_X11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;		&lt;span class=&quot;s&quot;&gt;&quot;x11-backend.so&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;weston_load_module()&lt;/code&gt;은 인자로 받은 첫 번째 문자열인 “name”에 위치한 라이브러리를 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;dlopen()&lt;/code&gt;으로 로딩한다. 인자로 받은 두 번째 문자열인 “entrypoint”는 로딩한 라이브러리 내에서 호출할 함수의 이름을 의미한다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;dlsym&lt;/code&gt;을 이용하여 “entrypoint”, 즉, 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;weston_backend_init()&lt;/code&gt;의 주소를 찾아 호출한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;libdl&lt;/code&gt;은 이처럼 런타임에 라이브러리를 로딩하고 해당 라이브러리의 심볼들에 접근할 수 있게끔 도와준다. &lt;code class=&quot;highlighter-rouge&quot;&gt;weston_load_module()&lt;/code&gt;에 도달하기까지의 콜 스택은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;libweston/compositor.c : weston_load_module(WL_EXPORT)&lt;/li&gt;
  &lt;li&gt;libweston/compositor.c : weston_compositor_load_backend(WL_EXPORT)&lt;/li&gt;
  &lt;li&gt;compositor/main.c : weston_compositor_load_backend()&lt;/li&gt;
  &lt;li&gt;compositor/main.c : load_backend()&lt;/li&gt;
  &lt;li&gt;compositor/main.c : main()&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 15 Jan 2018 06:07:36 +0900</pubDate>
        <link>http://baek9.github.io/graphics/2018/01/15/%EA%B7%B8%EB%9E%98%ED%94%BD_%EC%B9%B4%EB%93%9C%EC%97%90_%EB%8C%80%EC%9D%91%EB%90%98%EB%8A%94_DRM_%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4_%EB%85%B8%EB%93%9C_%EC%B0%BE%EA%B8%B0.html</link>
        <guid isPermaLink="true">http://baek9.github.io/graphics/2018/01/15/%EA%B7%B8%EB%9E%98%ED%94%BD_%EC%B9%B4%EB%93%9C%EC%97%90_%EB%8C%80%EC%9D%91%EB%90%98%EB%8A%94_DRM_%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4_%EB%85%B8%EB%93%9C_%EC%B0%BE%EA%B8%B0.html</guid>
        
        <category>Linux</category>
        
        <category>DRM</category>
        
        <category>udev</category>
        
        
        <category>Graphics</category>
        
      </item>
    
      <item>
        <title>자바스크립트의 가비지컬렉션과 메모리 누수</title>
        <description>&lt;p&gt;크롬에 구현된 자바스크립트 엔진인 V8은 주기적인 가비지컬렉션을 수행한다고 알려져있다. 이와 관련한 정보를 검색하다가 Daniel Khan이 작성한 글을 그대로 따라해보고, 느낀 점을 정리해본다. 해당 글은 아래 링크에서 읽어볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.codeship.com/understanding-garbage-collection-in-node-js/&quot;&gt;Understanding Garbage Collection and Hunting Memory Leaks in Node.js&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;resident-set&quot;&gt;Resident Set&lt;/h2&gt;

&lt;p&gt;V8은 ‘Resident Set’이라는 구조로 메모리를 운용한다. JVM(Java Virtual Machine)이 메모리를 여러 세그먼트(Segment)로 나누는 것과 같이, Resident Set 구조에 의해 메모리는 Code, Stack, Heap 영역으로 나뉜다고 한다. 이 부분에 대해서는 좀 더 알아볼 필요가 있다.&lt;/p&gt;

&lt;h2 id=&quot;processmemoryusage&quot;&gt;process.memoryUsage()&lt;/h2&gt;

&lt;p&gt;Node.js 역시, 크롬과 마찬가지로 자바스크립트를 해석하기 위해 V8을 사용한다. Node.js는 &lt;code class=&quot;highlighter-rouge&quot;&gt;process.memoryUsage()&lt;/code&gt;라는 함수를 제공하는 것으로 보인다. Resident Set의 크기, 힙(Heap)의 크기, 사용중인 힙의 크기를 알 수 있는 것으로 보인다.&lt;/p&gt;

&lt;h2 id=&quot;garbage-collection&quot;&gt;Garbage Collection&lt;/h2&gt;

&lt;p&gt;기존의 C, C++에서는 프로그래머가 직접 메모리를 할당하고 해제해야하는 것과 달리 자바스크립트는 그럴 필요가 없다. 자바스크립트에서 사용되는 요소들 중, 사용되지 않는 요소들은 가비지컬렉션(Garbage Collection)에 의해 자동으로 메모리에서 제거되기 때문이다. 특히, V8은 성능적인 이유로 두 가지 가비지컬렉션을 제공한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Scavenge : 빠른, 빈번히, 그러나 불완전한 가비지 컬렉션&lt;/li&gt;
  &lt;li&gt;Mark-Sweep : 느린, 드물게, 그러나 완전한 가비지 컬렉션&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;memory-leak&quot;&gt;Memory Leak&lt;/h2&gt;

&lt;p&gt;특정 요소가 미래에 사용될 일이 없음에도 불구하고 메모리를 계속 점유 중인 상황을 ‘Memory Leak’이 발생했다고 한다. Memory Leak이 누적 발생하여 할당 가능한 메모리를 초과하는 순간, 프로세스는 죽어버릴 것이다.&lt;/p&gt;

&lt;h2 id=&quot;javascripts-scope&quot;&gt;JavaScript’s Scope&lt;/h2&gt;

&lt;p&gt;저자는 Memory Leak을 의도적으로 유도하는 코드를 제공한다. 본 글에 해당 코드를 수록하진 않는다. 해당 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수를 호출할수록 Memory Leak이 누적 발생한다. 해당 함수를 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;originalThing&lt;/code&gt;이 &lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;과 동일한 객체를 참조하는데 이 객체는 이전의 &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수 호출 시에 생성된 것이다. 현재의 &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수 호출 시에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;으로 하여금 새로이 생성된 객체를 참조하게 한다.&lt;/p&gt;

&lt;p&gt;전역 객체인 &lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수가 호출될 때마다 갱신되어 매번 새로이 생성된 객체를 참조한다. 따라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;originalThing&lt;/code&gt;, 즉, 이전의 &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수 호출에서 생성되었던 객체는 더 이상 사용될 일이 없으므로 메모리에서 제거되어야 한다 원래는, 가비지컬렉션에 의해서.&lt;/p&gt;

&lt;p&gt;그럼에도 불구하고 Memory Leak이 발생하는 원인은 &lt;code class=&quot;highlighter-rouge&quot;&gt;unused()&lt;/code&gt; 함수에 있다. 이를 이해하려면 자바스크립트의 유효 범위(scope)를 이해하여야 한다. 자바스크립트에서는 함수 안에 함수가, 즉, 함수가 중첩된 경우에 내부 함수가 외부 함수에 위치한 요소들을 참조할 수 있다. 결국, &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수 내 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;의 메소드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;someMethod()&lt;/code&gt;는 외부 함수에 위치한 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;unused()&lt;/code&gt;를 참조할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;originalThing&lt;/code&gt;은 얼핏보기에 서로 연관이 없어 보인다. 하지만 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;이 소유한 메소드 &lt;code class=&quot;highlighter-rouge&quot;&gt;someMethod()&lt;/code&gt;가 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;unused&lt;/code&gt;를 참조하고, 이는 다시 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;originalThing&lt;/code&gt;을 참조한다. 결국, &lt;code class=&quot;highlighter-rouge&quot;&gt;originalThing&lt;/code&gt;은 메모리에서 제거되지 못하고 Memory Leak이 발생한다.&lt;/p&gt;

&lt;h2 id=&quot;closure&quot;&gt;Closure&lt;/h2&gt;

&lt;p&gt;자바스크립트는 넓은 유효 범위 덕분에 C나 C++에서는 구현이 번거로웠던 클로저(Closure)를 손쉽게 구현할 수 있다. 클로저는 콜백으로 많이 이용된다. 넓은 유효 범위는 함수의 ‘호출’ 순간에도 ‘선언’ 당시의 문맥 속에서 동작하도록 하기 때문이다. 이 부분도 좀 더 알아볼 필요가 있다.&lt;/p&gt;

&lt;h2 id=&quot;inspector&quot;&gt;Inspector&lt;/h2&gt;

&lt;p&gt;웹 개발자들이 잘 알고 있을 개발자 도구, 즉, 웹 인스펙터(Inspector)는 의외로 많은 기능을 담고 있다. 본문에서는 Memory Leak이 발생한 것을 ‘인스펙터&amp;gt;프로파일(profile)&amp;gt;힙 스냅샷(Heap Snapshot)’ 기능으로 보여주고 있다. 인스펙터는 웹 개발자 뿐만 아니라, 브라우저 개발자에게도 상당한 도움되는 도구인 것 같다. 본문과 달리, 나는 인스펙터가 제공하는 자바스크립트 콘솔(console)로 Memory Leak이 발생한 것을 확인해보았다.&lt;/p&gt;

</description>
        <pubDate>Thu, 30 Nov 2017 08:24:45 +0900</pubDate>
        <link>http://baek9.github.io/javascript/v8/2017/11/30/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98_%EA%B0%80%EB%B9%84%EC%A7%80%EC%BB%AC%EB%A0%89%EC%85%98%EA%B3%BC_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%88%84%EC%88%98.html</link>
        <guid isPermaLink="true">http://baek9.github.io/javascript/v8/2017/11/30/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98_%EA%B0%80%EB%B9%84%EC%A7%80%EC%BB%AC%EB%A0%89%EC%85%98%EA%B3%BC_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%88%84%EC%88%98.html</guid>
        
        <category>JavaScript</category>
        
        <category>V8</category>
        
        <category>Garbage Collection</category>
        
        
        <category>JavaScript</category>
        
        <category>V8</category>
        
      </item>
    
      <item>
        <title>자바스크립트의 프로토타입 체인</title>
        <description>&lt;p&gt;자바스크립트(JavaScript)는 흔히 프로토타입(prototype) 기반의 언어라고 불린다. 프로토타입은 직역하면 원형이라는 의미이다. 자바스크립트로 생성한 모든 객체는 원형, 즉, 프로토타입 객체와 함께 쌍을 이룬다. 이러한 구조를 활용하면 C++을 이용한 객체 지향 프로그래밍(OOP : Object-Oriented Programming)에서 중요한 개념 중의 하나인 상속(inheritance)을 자바스크립트에서도 손쉽게 구현할 수 있다. 자바스크립트에서는 이를 ‘프로토타입 체인(prototype chain)’ 이라고 부른다. 프로토타입 체인을 이해하기 위해서는 우선 프로토타입 객체에 대한 감을 잡을 필요가 있다.&lt;/p&gt;

&lt;h2 id=&quot;객체의-생성&quot;&gt;객체의 생성&lt;/h2&gt;

&lt;p&gt;자바스크립트에서는 정의된 모든 함수(function)를 객체를 생성하기 위한 생성자로 활용할 수 있다. C++에서 클래스 이름과 동일한 이름을 가진 멤버 함수가 생성자로 지정되는 것과는 상당히 다른 부분이다. 자바스트립트에서는 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt;라는 함수를 제공하고 있으며, &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;라는 연산자를 이용하여 다음과 같이 객체를 생성할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한, 이러한 방법말고도 객체 리터럴 표기법(Object literal notation)을 이용하여 객체를 생성할 수도 있다. JSON(JavaScript Object Notation)과 유사하지만 차이점이 존재한다. 객체 리터럴 표기법을 이용하여 다음과 같이 객체를 생성할 수 있으며, 바로 위의 코드와 동일하다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;객체&quot;&gt;객체&lt;/h2&gt;

&lt;p&gt;자바스크립트의 자료형에는 null, undefined, boolean, number, string, symbol, object의 7가지가 존재한다. 앞의 6가지는 이름만으로 어떤 것을 의미하는지 명백히 파악할 수 있는 만큼 기본 자료형(primitive)으로 분류된다. 기본 자료형이 아닌 모든 것들은 전부 object 타입, 즉, 객체이다. 앞서 살펴본 것처럼 JSON과 유사한 객체 리터럴 표기법으로 객체가 생성된다는 점으로 미루어 보아 객체는 키와 값의 쌍들로 구성된다고 어렴풋이 추측해 볼 수 있겠다. 다만, 키라는 용어 대신 속성(property)이라는 이름을 사용한다. 자바스크립트 객체는 속성과 값의 쌍으로 구성된다.&lt;/p&gt;

&lt;h2 id=&quot;객체-1&quot;&gt;객체&lt;/h2&gt;

&lt;p&gt;기본 자료형이 아닌 모든 것들은 객체이므로 함수도 객체이다. 따라서 앞에서 언급한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt; 힘수도 객체이다. 객체로 객체를 만든 것이다. C나 C++을 주로 다뤘다면 충격적으로 다가오는 사실 중의 하나일 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;함수-객체&quot;&gt;함수 객체&lt;/h2&gt;

&lt;p&gt;앞서 설명했듯이 객체는 프로퍼티와 값의 쌍으로 구성되며, 자바스크립트의 모든 자료형이 값에 대입될 수 있다. 따라서 객체인 함수, 즉, 함수 객체도 속성과 값의 쌍을 여럿 가질 수 있다. 함수 객체는 특별히 &lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt; 이라는 속성을 가지는데, 이는 해당 객체의 프로토타입 객체를 가리킨다. 앞서도 언급했둣이 자바스크립트의 모든 객체는 프로토타입 객체와 한 쌍을 이룬다. 즉, 아래와 같이 함수를 정의하는 순간,&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;funcA&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;object 타입인 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA&lt;/code&gt;가 생성되며, 이 객체는 함수 객체의 특징 상 &lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;이라는 속성을 갖는다. 특정 객체의 속성을 참조하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;을 이용하면 된다. 즉, 아래와 같이 함수 객체의 프로토타입 객체를 참조할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;funcA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;프로토타입-객체&quot;&gt;프로토타입 객체&lt;/h2&gt;

&lt;p&gt;함수 객체가 생성되는 순간에 프로토타입 객체가 함께 생성된다. 이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt; 속성으로 참조할 수 있다. 프로토타입 객체도 객체이므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt; 함수 또는 객체 리터럴 표기법으로 생성하는 것과 그 원리는 다를 바 없다. 다만, 일반적인 객체들과 다른 점은 개발자가 모르는 사이에 생성된다는 점이다. 따라서, 앞서 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA&lt;/code&gt;를 생성하는 순간 아래의 코드가 암묵적으로 수행되는 것으로 이해해 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;funcA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;funcA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드로 이해를 해보면, 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA&lt;/code&gt;가 생성될 때 프로토타입 객체가 생성된다. 함수 객체 입장에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;이라는 속성으로 프로토타입 객체를 참조할 수 있다. 한편, 프로토타입 객체는 두 가지 속성, &lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;를 가진다. 전자는 다시 역으로 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA&lt;/code&gt;를 가리킨다. 여기까지가 함수 객체와 생성되는 프로토타입 객체의 생성 과정과 실체에 대한 내용이다.&lt;/p&gt;

&lt;h2 id=&quot;프로토타입-체인&quot;&gt;프로토타입 체인&lt;/h2&gt;

&lt;p&gt;프로토타입 객체에 대하여 한 가지 설명하지 않은 것은, 프로토타입 객체가 가진 두 가지 속성 중 하나인 &lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 속성이다. 이 속성은 함수 객체를 제외한 나머지, 그러니까, 프로토타입 객체를 포함한 일반 객체들이 생성될 때, 생성의 원인이 되는 객체의 프로토타입을 참조하기 위한 속성이다. 바로 앞 예제에서 프로토타입 객체 생성의 ‘원인’인 객체는 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt;이므로, 바로 이 함수 객체와 쌍을 이루는 프로토타입 객체를 참조한다는 것이다. 결국, 다음의 등식은 참이다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;funcA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;앞서, 모든 함수는 일반 객체를 생성하기 위한 생성자로서 활용할 수 있다고 했다. 따라서 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt;를 이용해서 또다른 객체를 만들 수 있는 것처럼, 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA()&lt;/code&gt;를 이용해서 다음과 같이 또다른 객체를 생성할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;objA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;funcA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;앞서 설명한 것처럼 일반 객체인 &lt;code class=&quot;highlighter-rouge&quot;&gt;objA&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;라는 속성을 가진다. 해당 객체의 생성은 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA()&lt;/code&gt;이 원인이므로 다음의 등식은 참이다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;objA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;funcA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두 등식을 나란히 놓고보면,&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;objA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;funcA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;funcA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 속성으로 인해 일반 객체를 시작으로 두 개의 프로토타입 객체까지 연달아 연결된 것이다. 바로 이것을 프로토타입 체인이라고 한다. 이러한 이유로 자바스크립트 체인을 이용하면 OOP의 중요한 개념 중의 하나인 상속을 구현할 수 있다. 같은 방법으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;objB&lt;/code&gt; 객체를 만든다면, ‘objA`와 다른 객체이지만 동일한 프로토타입 객체를 참조한다. 이러한 특징을 이용하면 프로토타입 객체에 임의의 속성을 생성하여 C++에서의 클래스 변수처럼 사용할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 26 Nov 2017 07:12:24 +0900</pubDate>
        <link>http://baek9.github.io/javascript/v8/2017/11/26/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98_%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EC%B2%B4%EC%9D%B8.html</link>
        <guid isPermaLink="true">http://baek9.github.io/javascript/v8/2017/11/26/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98_%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EC%B2%B4%EC%9D%B8.html</guid>
        
        <category>JavaScript</category>
        
        <category>Prototype</category>
        
        
        <category>JavaScript</category>
        
        <category>V8</category>
        
      </item>
    
  </channel>
</rss>
