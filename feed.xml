<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>evening(code)</title>
    <description>A Jekyll theme - Medium inspired
</description>
    <link>http://baek9.github.io/</link>
    <atom:link href="http://baek9.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 05 Apr 2019 15:03:05 +0900</pubDate>
    <lastBuildDate>Fri, 05 Apr 2019 15:03:05 +0900</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>Integer Overflow in V8</title>
        <description>&lt;p&gt;최근 취약점들을 살펴보면 순수하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;V8&lt;/code&gt;과 관련된 취약점은 별로 없고, 그나마 JavaScript로 시작하되 최종적으로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Blink&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chrome&lt;/code&gt;에서 취약점이 발생하는 경우들이 많은 것 같다. 와중에 최근에 등록된 버그가 눈길을 끌었다. &lt;code class=&quot;highlighter-rouge&quot;&gt;V8&lt;/code&gt; 내부에서 정수 오버플로우(Integer Overflow)를 유발하는 PoC(Proof of Concept)를 제시하고 있었다. 대략적인 &lt;code class=&quot;highlighter-rouge&quot;&gt;V8&lt;/code&gt;의 구조와 정수 오버플로우가 어떤 것인지 알게된 의미있는 분석이었다.&lt;/p&gt;

&lt;h2 id=&quot;regexpprototypereplace&quot;&gt;RegExp.prototype[@@replace]&lt;/h2&gt;

&lt;p&gt;해당 PoC는 결국에 C++ 함수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime_RegExpReplace()&lt;/code&gt;에서 발현된다.(이하 RegExpReplace) 이 함수는 자바스크립트 레벨에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp.prototype[@@replace]&lt;/code&gt; 메소드(이하 replace)에 대응되는 함수이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt;는 무엇일까? 정규표현식을 표현하고 처리하기 위한 객체로 이해하면 된다. 다음 코드를 예로 들면,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var re = /-/g; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;re는 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; 객체이다. re에 대입한 “/-/g”의 의미는 임의의 문장에서 “-“와 일치하는 모든 부분을 의미한다. 뒤에 붙은 ‘g’는 “global”의 약자로서 일치하는 부분을 모두 식별하겠다는 의미이다. 한편, MDN(Mozilla Developers Network)에서 제시하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;replace()&lt;/code&gt; 메소드의 용법과 예제는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var str = '2016-01-01';
// regexp[Symbol.replace](str, newSubStr|function)
var newstr = re[Symbol.replace](str, '.');
console.log(newstr);  // 2016.01.01
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;replace()&lt;/code&gt; 메소드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; 객체의 메소드이다. 이 메소드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Symbol&lt;/code&gt; 타입으로 정의되어 있다. 이 타입은 최신 ECMA Script에 새로 추가된 것으로서, 잘 모르기도 하지만 본 포스트의 주제와 맞지 않으므로 생략한다. 어쨌든, &lt;code class=&quot;highlighter-rouge&quot;&gt;replace()&lt;/code&gt; 메소드는 두 개의 인자를 받는다. 첫 번째 인자는 원본 문자열이고, 두 번째 인자는 원본 문자열에서 정규표현식과 일치하는 부분을 치환하고자 하는 치환 문자열이다. 위 예에서 “2016-01-01“이라는 원본 문자열은 ‘-‘이 ‘.’으로 모두 치환된다.&lt;/p&gt;

&lt;h2 id=&quot;regexpprototypeexec&quot;&gt;RegExp.prototype.exec()&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 메소드는 원본 문자열에서 정규표현식과 일치하는 부분을 객체 형태로 반환한다. 아래 예제를 보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var re = /foo/g;
var result = re.exec('___foo___foo');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;객체 result는 원본 문자열에서 주어진 정규표현식과 일치하는 부분들에 대한 정보를 담는다. 아래는 해당 객체의 내용을 출력해 본 것이다.원본 문자열인 “__&lt;em&gt;foo&lt;/em&gt;__foo”를 input 프로퍼티에, 정규표현식과 일치하는 부분 문자열인 “foo”를 0 프로퍼티에 담고 있다. 두 번 일치하지만 “foo”는 하나이므로 length가 1인 것으로 생각된다. 또, 원본 문자열에서 정규표현식과 일치하는 첫 번째 문자열이 시작하는 위치가 4이므로, index 프로퍼티에 4가 저장된 것으로 생각된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;result = {
  0:&quot;foo&quot;
  index:3
  input:&quot;___foo___foo&quot;
  length:1
  __proto__:Array(0)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;regexputilsregexpexec&quot;&gt;RegExpUtils::RegExpExec()&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp.prototype.exec()&lt;/code&gt; 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;V8&lt;/code&gt; 내부에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpExec()&lt;/code&gt; 함수를 호출하는 것으로 생각된다. 당연한 말이지만, 정규표현식과 일치하는 부분을 찾아서 치환하기 위해서는 먼저 “찾아야” 한다. 따라서, &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpReplace()&lt;/code&gt; 함수는 ECMA Script에 기술된 대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpExec()&lt;/code&gt; 함수를 호출한다. 해당 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; 클래스의 객체인 result를 반환한다. 아래는 해당 객체에 대하여, &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; 클래스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Print()&lt;/code&gt; 멤버함수를 실행시킨 결과이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x24c761393899: [JSArray]
 - map: 0x3288b1786611 &amp;lt;Map(HOLEY_ELEMENTS)&amp;gt; [FastProperties]
 - prototype: 0x39681e485539 &amp;lt;JSArray[0]&amp;gt;
 - elements: 0x24c7613938d1 &amp;lt;FixedArray[1]&amp;gt; [HOLEY_ELEMENTS]
 - length: 1
 - properties: 0x17db08a02251 &amp;lt;FixedArray[0]&amp;gt; {
    #length: 0x17db08a4ff89 &amp;lt;AccessorInfo&amp;gt; (const accessor descriptor)
    #index: 3 (data field 0)
    #input: 0x39681e4aa699 &amp;lt;String[12]: ___foo___foo&amp;gt; (data field 1)
    #groups: 0x17db08a022e1 &amp;lt;undefined&amp;gt; (data field 2)
 }
 - elements: 0x24c7613938d1 &amp;lt;FixedArray[1]&amp;gt; {
           0: 0x24c761393879 &amp;lt;String[3]: foo&amp;gt;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;객체 result의 정보가 출력되는데, 이를 통해 대략 알 수 있는 것은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JSArray&lt;/code&gt; 클래스의 객체이다. (JSArray 클래스는 Object 클래스를 상속 받음)&lt;/li&gt;
  &lt;li&gt;elements와 properties라는 FixedArray 객체를 갖는다.&lt;/li&gt;
  &lt;li&gt;elements 객체의 엔트리 0에는 문자열 “foo”가 저장되어 있다.&lt;/li&gt;
  &lt;li&gt;length는 1이다. 객체 elements의 엔트리 개수를 의미한다.&lt;/li&gt;
  &lt;li&gt;properties 객체는 index, input, group이라는 엔트리를 가진다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;앞서, 자바스크립트 계층에서 result 객체를 출력한 내용과, C++ 레이어에서 result 객체를 출력한 내용이 동일한 것으로 생각된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;JSArray&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; 클래스에 대해서는 추후에 별도로 살펴보아야 할 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;flow-of-runtime_regexpreplace&quot;&gt;Flow of &lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime_RegExpReplace&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;동일한 방법으로 해당 PoC에 대하여 C++ 레이어에서 객체 result의 정보를 출력해보면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x2bea81a10e31: [JS_OBJECT_TYPE]
 - map: 0x98850a8cf41 &amp;lt;Map(HOLEY_ELEMENTS)&amp;gt; [FastProperties]
 - prototype: 0x22efc2684649 &amp;lt;Object map = 0x98850a822b1&amp;gt;
 - elements: 0x7268cc02251 &amp;lt;FixedArray[0]&amp;gt; [HOLEY_ELEMENTS]
 - properties: 0x7268cc02251 &amp;lt;FixedArray[0]&amp;gt; {
    #length: &amp;lt;unboxed double&amp;gt; 4.29497e+09 (data field 0)
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 PoC는 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 메소드를 임의의 함수로 대체한다. 대체한 함수는 0xfffffffe를 반환한다. 한편, 위 결과를 보면 FixedArray 객체인 properties의 엔트리 length가 double 타입의 4.29497e+09 값임을 알 수 있다. 이 값은 0xfffffffe와 동일한 값이다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 메소드가 반환하는 double 타입의 값이 length 프로퍼티에 저장된다.&lt;/p&gt;

&lt;p&gt;length는 원본 문자열에서 정규표현식과 일치하는 부분의 개수이다. 따라서, &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpReplace()&lt;/code&gt; 함수는 본연의 목적을 위해 length 만큼 루프를 돌면서 정규표현식과 일치하는 모든 부분들을 치환하여야 한다. 이러한 루프는 코드 상에서는 물론, ECMA Script 명세에서도 확인할 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpReplace()&lt;/code&gt; 함수는 객체 result의 length 프로퍼티의 값을 int 타입의 변수인 captures_length에 저장한다.&lt;/p&gt;

&lt;h2 id=&quot;integer-overflow-by-explicit-type-conversion&quot;&gt;Integer overflow by explicit type conversion&lt;/h2&gt;

&lt;p&gt;정수 오버플로우가 발현되는 부분은 이 &lt;a href=&quot;https://cs.chromium.org/chromium/src/v8/src/runtime/runtime-regexp.cc?type=cs&amp;amp;rcl=365bb5bb4a1dd62908baf0fad9d075fbcab695ed&amp;amp;l=1797&quot;&gt;link&lt;/a&gt; 부분이다. 변수 captures_length는  &lt;code class=&quot;highlighter-rouge&quot;&gt;PositiveNumberToUint32()&lt;/code&gt; 함수를 통해 객체 result의 length 프로퍼티의 값을 받는다. 함수의 이름에서부터 감이 오기 시작한다. 해당 함수는 length 프로퍼티의 값을 받아와 uint 타입으로 변환하여 반환한다. 문제는 이 반환 값을 받는 변수인 captures_length가 int 타입이라는 점이다. 결국, length 프로퍼티의 값이 4,294,967,295 값임에도 변수 captures_length의 값은 -2가 된다.&lt;/p&gt;

&lt;h2 id=&quot;crashing&quot;&gt;Crashing&lt;/h2&gt;

&lt;p&gt;이후의 코드를 따라가다 보면, int 타입의 변수 argc가 contents_length + 2로 계산이 되어 결국 0이 된다. 만약, PoC가 변조한 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 메소드를 0xfffffffd가 반환하도록 수정하면 argc의 값은 -1이 된다. 결국, 이후에 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExpReplace()&lt;/code&gt; 함수는 0 이하의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Handle&amp;lt;Object&amp;gt;&lt;/code&gt; 배열을 동적할당 시도하는데, 이 과정에서 크로미움은 강제로 OOM(Out of Memory) 에러를 발생시키고 렌더러 프로세스는 종료된다.&lt;/p&gt;

</description>
        <pubDate>Tue, 03 Apr 2018 07:14:52 +0900</pubDate>
        <link>http://baek9.github.io/javascript%20&%20v8/2018/04/03/Integer_Overflow_in_RegExp_of_V8.html</link>
        <guid isPermaLink="true">http://baek9.github.io/javascript%20&%20v8/2018/04/03/Integer_Overflow_in_RegExp_of_V8.html</guid>
        
        
        <category>JavaScript &amp; V8</category>
        
      </item>
    
      <item>
        <title>Playing with JSON in Chromium</title>
        <description>&lt;p&gt;다른 포스트에서도 언급했거나 언급하겠지만, 크로미움은 그 자체로 매우 풍부한 라이브러리 집합이다. 예를 들면, &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;GURL&lt;/code&gt; 클래스를 이용하면 손쉽게 스레드를 만들고 관리할 수 있으며, URL도 입맛대로 다룰 수 있다. (scheme만 따로 추출하려고 굳이 파싱하지 않아도 되는) 이 밖에도 유용한 클래스들이 많이 존재하며, 이들은 크로미움의 &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; 네임스페이스에 존재한다.&lt;/p&gt;

&lt;p&gt;크로미움은 웹 브라우저이므로 당연히 JSON(JavaScript Object Notation)을 처리하기 위한 모듈이 존재할 것이다. 아니, 존재하여야만 한다. 실제로, &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; 네임스페이스 아래에 &lt;code class=&quot;highlighter-rouge&quot;&gt;JSONReader&lt;/code&gt; 클래스가 존재한다. 물론, &lt;code class=&quot;highlighter-rouge&quot;&gt;libjson-c&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;libjsoncpp&lt;/code&gt;와 같은 라이브러리를 활용하는 옵션도 있겠지만, 크로미움 개발자라면 굳이 이를 활용할 필요가 없겠다. 본 포스트에는 크로미움 내에서 JSON을 다루는 방법을 담았다.&lt;/p&gt;

&lt;h2 id=&quot;open-and-read-file&quot;&gt;Open and read file&lt;/h2&gt;

&lt;p&gt;처리하고자 하는 대상은 파일 형태로 존재할 수도 있고, 네트워크로 받아와 바이트 스트림 형태로 존재할 수도 있다. 파일 형태도 결국은 처리를 위해서 바이트 스트림 형태로 변환해야 하므로 전자의 경우를 보겠다.&lt;/p&gt;

&lt;p&gt;크로미움은 심지어 파일 경로를 처리하는 클래스까지 갖고 있다. 해당 클래스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;FilePath&lt;/code&gt;이다. 굳이 파일 경로를 처리하는 클래스가 필요한 지 의문이 들 수 있지만, 플랫폼마다 파일 경로를 구성하는 규칙이 다르기 때문에라도 매우 유용하고 중요한, 생각보다 복잡한 클래스이다. 처리하고자 하는 파일이 test.json이고, 파일 경로가 “/path/to/file/test.json”이라면 다음과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;FilePath&lt;/code&gt; 객체를 생성할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;base::FilePath json_path(&quot;/path/to/file/test.json&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드로 json_path라는 &lt;code class=&quot;highlighter-rouge&quot;&gt;FilePath&lt;/code&gt; 객체가 생성된다. 이제 이 객체를 이용하여 test.json을 읽고, 그 내용을 바이트 스트림 형태로 가져와야 한다. 이 작업은 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReadFileToString()&lt;/code&gt; 함수를 이용하여 아래와 같이 수행할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::string json_string;
base::ReadFileToString(json_path, &amp;amp;json_string);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드로 test.json의 내용이 문자열 객체인 json_string에 저장된다.&lt;/p&gt;

&lt;h2 id=&quot;parse-json-and-ready-to-play-with-it&quot;&gt;Parse JSON and Ready to play with it&lt;/h2&gt;

&lt;p&gt;json_string은 test.json의 내용을 바이트 스트림으로 저장하고 있을 뿐인 문자열 객체에 불과하다. 이 문자열을 JSON 문법에 맞추어 취급하기 쉬운 형태로 파싱하여야 한다. 생각만해도 번거로운 이 작업은 &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; 네임스페이스 내 &lt;code class=&quot;highlighter-rouge&quot;&gt;JSONReader&lt;/code&gt; 클래스의 멤버 함수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Read()&lt;/code&gt;로 쉽게 처리할 수 있다. static 함수이므로 다음과 같이 활용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::unique_ptr&amp;lt;base::Value&amp;gt; json_structure;
json_structure = base::JSONReader::Read(json_str);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드로 json_structure라는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt; 객체가 생성된다. 이를 이용하여 test.json 내의 모든 키 값들을 추출할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;getting-a-dictionary-from-a-json&quot;&gt;Getting a dictionary from a JSON&lt;/h2&gt;

&lt;p&gt;JSON은 다음의 두 개의 구조를 바탕으로 구성된다. &lt;a href=&quot;https://www.json.org&quot;&gt;JSON 공식 홈페이지&lt;/a&gt;에 두 구조에 대한 간략한 설명이 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Collection
    &lt;ul&gt;
      &lt;li&gt;name/value pairs. In various languages this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Ordered list of values
    &lt;ul&gt;
      &lt;li&gt;realized as an array, vector, list, or sequence.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JSON은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ordered list&lt;/code&gt;로 구성된다. 따라서, JSON으로부터 이 두 구조를 얻어낼 수 있다는 것은 곧, JSON을 완벽하게 활용할 수 있다는 것이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ordered list&lt;/code&gt;를 구현하는 방법은 언어에 따라 다르다. 크로미움에서는 각각 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;로 표현한다. 그리고, &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; 네임스페이스에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt; 클래스를 상속받는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;ListValue&lt;/code&gt;라는 클래스가 존재한다. 뭔가 감이 오기 시작한다. 더 진행하기에 앞서서, test.json의 내용이 다음과 같다고 가정하자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
   &quot;key1&quot; : {
      &quot;key11&quot; : &quot;value11&quot;,
      &quot;key12&quot; : [ &quot;element121&quot;,
                  &quot;element122&quot;
                ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JSON 전쳬가 하나의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;, 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;이다. 따라서 앞서 파싱하여 얻어낸 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt; 객체인 json_structure로부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 객체를 얻어내야 한다. 그래야만 key11의 값인 “value11”과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ordered list&lt;/code&gt;인 key12가 포함하는 값들인 “element121”, “element122”를 추출할 수 있을 것이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 객체를 얻어내기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 클래스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;From()&lt;/code&gt; 함수를 이용하면 된다. static 함수이므로 다음과 같이 활용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::unique_ptr&amp;lt;base::DictionaryValue&amp;gt; json_dictionary;
json_dictionary = base::DictionaryValue::From(json_structure);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드로 json_dictionary라는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 객체를 얻어낼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;getting-a-value-which-type-is-string-from-a-dictionary&quot;&gt;Getting a value which type is “string” from a dictionary&lt;/h2&gt;

&lt;p&gt;크로미움에서만 그런지는 모르겠지만 “.”을 이용하여 특정 키의 경로를 표현할 수 있다. 예를 들어, Key11의 주소는 “key1.key11”이다. 이 경로를 이용하여 해당 키의 값을 추출할 수 있다. key11에 대응되는 값의 타입은 문자열이므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 클래스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;GetString()&lt;/code&gt; 함수를 아래와 같이 활용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::string key11_value;
json_dictionary-&amp;gt;GetString(&quot;key1.key11&quot;, &amp;amp;key11_value);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;getting-a-list-from-a-dictionary&quot;&gt;Getting a list from a dictionary&lt;/h2&gt;

&lt;p&gt;key12는 대괄호로 둘러쌓인 Ordered list, 즉, List이다. 따라서 이번에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 객체로부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::string&lt;/code&gt;이 아닌, &lt;code class=&quot;highlighter-rouge&quot;&gt;ListValue&lt;/code&gt;객체를 추출해야 한다. 이를 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt; 클래스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;GetList()&lt;/code&gt; 함수를 아래와 같이 활용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;base::ListValue* key12_list;
json_dictionary-&amp;gt;GetList(&quot;key1.key12&quot;, &amp;amp;key12_list);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;iterate-and-getting-a-value-which-type-is-string-from-a-list&quot;&gt;Iterate and getting a value which type is “string” from a list&lt;/h2&gt;

&lt;p&gt;앞서 얻어낸 &lt;code class=&quot;highlighter-rouge&quot;&gt;ListValue&lt;/code&gt; 객체인 key12_list의 원소들을 순회하여 Ordered list인 key12의 모든 원소들을 추출할 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;DictionaryValue&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ListValue&lt;/code&gt; 클래스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt; 클래스를 상속받는다. &lt;code class=&quot;highlighter-rouge&quot;&gt;ListValue&lt;/code&gt;의 경우에는 원소들이 부모 클래스인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt;가 정의하는 멤버 변수, &lt;code class=&quot;highlighter-rouge&quot;&gt;ListStorage&lt;/code&gt;에 저장된다. 아래와 같은 연쇄 대입 체인에 따르면,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// base/values.h
// https://cs.chromium.org/chromium/src/base/values.h?rcl=029daddc376494ee36c5d81cc51a5ade45002fb6&amp;amp;l=589
class ListValue : public Value {
using const_iterator = ListStorage::const_iterator;

}
// base/values.h
// https://cs.chromium.org/chromium/src/base/values.h?rcl=029daddc376494ee36c5d81cc51a5ade45002fb6&amp;amp;l=85
ListStorage = std::vector&amp;lt;Value&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ListStorage&lt;/code&gt;는 결국 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt; 객체이다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt; 객체를 순회하는 방법을 그대로 활용하여 원소들을 순회할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ListValue::const_iterator == std::vector&amp;lt;Value&amp;gt;::const_iterator&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;순회 중에 방문한 원소들의 타입은 무엇일까? 타입을 알아야 값을 추출할 수 있다. 위 등식에서도 알 수 있듯이, &lt;code class=&quot;highlighter-rouge&quot;&gt;iterator&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;const_iterator&lt;/code&gt;에 의해 참조하는 각 원소들은 base::Value* 또는 const base::Value*이다. 한편, &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt; 객체의 값은 멤버 함수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;GetString()&lt;/code&gt;으로 얻어낼 수 있다.(키 값의 타입이 문자열인 경우라면) 아래가 그 예제다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(base::ListValue::const_iterator it = key12_list-&amp;gt;begin(); 
     it != key12_list-&amp;gt;end(); ++it) {
   std::string key12_string() it-&amp;gt;GetString();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;full-example&quot;&gt;Full example&lt;/h2&gt;

&lt;p&gt;test.json으로부터 모든 값을 추출하는 전체 예제 코드는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;base::FilePath json_path(&quot;/path/to/file/test.json&quot;);
std::string json_string;
std::unique_ptr&amp;lt;base::Value&amp;gt; json_structure;
std::unique_ptr&amp;lt;base::DictionaryValue&amp;gt; json_dictionary;
std::string key11_value;
base::ListValue* key12_list;

base::ReadFileToString(json_path, &amp;amp;json_string);
json_structure = base::JSONReader::Read(json_str);
json_dictionary = base::DictionaryValue::From(json_structure);
json_dictionary-&amp;gt;GetString(&quot;key1.key11&quot;, &amp;amp;key11_value);
json_dictionary-&amp;gt;GetList(&quot;key1.key12&quot;, &amp;amp;key12_list);
for(base::ListValue::const_iterator it = key12_list-&amp;gt;begin(); 
     it != key12_list-&amp;gt;end(); ++it) {
   std::string key12_string() it-&amp;gt;GetString();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 19 Mar 2018 06:50:45 +0900</pubDate>
        <link>http://baek9.github.io/chromium/json/2018/03/19/Playing_with_JSON_in_Chromium.html</link>
        <guid isPermaLink="true">http://baek9.github.io/chromium/json/2018/03/19/Playing_with_JSON_in_Chromium.html</guid>
        
        
        <category>Chromium</category>
        
        <category>JSON</category>
        
      </item>
    
      <item>
        <title>VS Code를 이용한 원격 개발 환경 구성</title>
        <description>&lt;p&gt;커널 개발 시에는 빌드, 테스트, 디버깅까지 이어지는 과정이 꽤나 번거롭다. 이 때문에 QEMU와 gdb를 연동하여 개발 환경을 구축하는 것을 보았다. 그에 비할 바인지는 모르겠지만 리눅스 그래픽스 스택과 관련한 개발에서도 몇 애로점이 있었다. 귀찮더라도 최초에 개발 환경을 구축하는 것이 낫다는 것이 정신 건강에 이로움을 나중에야 깨달았다.&lt;/p&gt;

&lt;p&gt;보통, 리눅스를 이용한 개발은 가상머신에서 진행한다. 우분투 같은 배포판은 가상머신에 설치해도 가상머신 창의 크기에 따라 자동적으로 해상도가 조정된다. 하지만 GNOME이나 KDE와 같은 GUI 데스크톱 환경이 제공되지 않는 환경에서의 개발은 매우 불편하다. 가상머신 창의 크기를 키워도 800x600의 해상도로 고정되기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;putty--vs-code&quot;&gt;putty + VS Code&lt;/h2&gt;

&lt;p&gt;putty를 이용하면 호스트에서 원격으로 가상머신 상에 접속하여 개발이 가능하다. 심지어 &lt;code class=&quot;highlighter-rouge&quot;&gt;DISPLAY&lt;/code&gt; 환경변수의 값을 “:0”으로 설정하면 원격으로 리눅스 그래픽스 스택을 테스트할 수 있다! 물론, 디버깅 용도로 출력되는 메세지는 별도로 putty를 통해 확인할 수 있다는 점도 큰 장점이다. 한편, 코드 분석하기 위해서는 VS Code를 주로 사용하는데, 개발은 putty, 테스트는 가상머신, 분석은 VS Code에서 수행하니 매우 정신이 없었다. 물론, vi + ctags를 활용하면 putty에서 개발과 분석을 통합할 수 있지만 VS Code가 매우 좋은 도구라서 다른 방법을 찾기 시작했다.(&lt;del&gt;vi와 친하지 않다…&lt;/del&gt;)&lt;/p&gt;

&lt;h2 id=&quot;remote-vs-code&quot;&gt;Remote VS Code&lt;/h2&gt;

&lt;p&gt;VS Code는 Remote VS Code라는 플러그인을 제공한다. 이 플러그인은 이런거다. 우선, 가상머신에 rmate라는 바이너리와 ssh를 설치한다.(ssh는 putty를 사용하기 위해서도 필요하다) ssh를 설치했으므로 VS Code가 제공하는 쉘 상에서 역 터널링(reverse tunneling) 방법으로 가상머신에 접속한다. 이후, 쉘에서 “rmate [파일 경로]”를 입력하면 해당 파일을 VS Code에서 편집할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 20 Jan 2018 07:09:26 +0900</pubDate>
        <link>http://baek9.github.io/devtools/2018/01/20/VS_Code%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EC%9B%90%EA%B2%A9_%EA%B0%9C%EB%B0%9C_%ED%99%98%EA%B2%BD_%EA%B5%AC%EC%84%B1.html</link>
        <guid isPermaLink="true">http://baek9.github.io/devtools/2018/01/20/VS_Code%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EC%9B%90%EA%B2%A9_%EA%B0%9C%EB%B0%9C_%ED%99%98%EA%B2%BD_%EA%B5%AC%EC%84%B1.html</guid>
        
        
        <category>Devtools</category>
        
      </item>
    
      <item>
        <title>그래픽 카드에 대응되는 DRM 디바이스 노드 찾기</title>
        <description>&lt;p&gt;DRM(Direct Rendering Manager)는 DRI(Direct Rendering Infrastructure)를 지원하는 그래픽 카드를 위한 디바이스 드라이버를 말한다. DRM과 DRI에 대해서는 다음 기회에 정리해야 할 것 같다. 이 노트에서는 주 그래픽 카드에 대응되는 DRM의 디바이스 노드를 찾는 방법만 정리하였다.&lt;/p&gt;

&lt;p&gt;보통은 /dev/dri/card0를 주 그래픽 카드에 대응되는 디바이스 노드라고 봐도 무방하다. 단, 그래픽 카드가 DRI를 지원하지 않는 경우 또는 복수의 그래픽 카드를 사용하는 경우를 제외하고 말이다. 따라서, 좀 더 확실한 방법으로 주 그래픽 카드를 식별할 수 있는 방법이 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;udevadm을-이용한-방법&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;udevadm&lt;/code&gt;을 이용한 방법&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;udevadm&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt;에 의해 생성된 디바이스 노드에 대응되는 장치의 속성들을 출력한다. 주 그래픽 카드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;boot_vga&lt;/code&gt; 속성의 값으로 1을 갖는다. 따라서, &lt;code class=&quot;highlighter-rouge&quot;&gt;udevadm&lt;/code&gt;으로 출력한 특정 디바이스 노드의 속성 중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;boot_vga&lt;/code&gt; 속성의 값이 1이라면, 해당 노드는 주 그래픽 카드에 대응된다. 만약, “/dev/dri/card0”에 대응되는 그래픽 카드의 속성들을 보기 위해서는 아래와 같이 명령어를 입력하면 된다. “/dev/dri/card0”는 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt; 관련 용어로 &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVNAME&lt;/code&gt;이라고 부르는 듯 하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ udevadm info --query=all --name=/dev/dri/card0
	
	P: /devices/pci0000:00/0000:00:0f.0/drm/card0
	N: dri/card0
	E: DEVNAME=/dev/dri/card0
	E: DEVPATH=/devices/pci0000:00/0000:00:0f.0/drm/card0
	E: DEVTYPE=drm_minor
	E: ID_FOR_SEAT=drm-pci-0000_00_0f_0
	E: ID_PATH=pci-0000:00:0f.0
	E: ID_PATH_TAG=pci-0000_00_0f_0
	E: MAJOR=226
	E: MINOR=0
	E: SUBSYSTEM=drm
	E: TAGS=:master-of-seat:uaccess:seat:
	E: USEC_INITIALIZED=8444405
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt;는 핫플러그(Hotplug) 방식으로 연결된 장치들에 대해 “/dev” 아래에 디바이스 노드들을 생성한다. 사실, &lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;sysfs&lt;/code&gt;가 제공하는 장치들의 정보를 가지고 “/dev”를 구성한다고 한다. 장치들의 정보는 “/sys” 아래에 계층적으로 제공되며, 이 경로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt; 관련 용어로 &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVPATH&lt;/code&gt;라고 한다. 위 결과를 통해서, &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVNAME&lt;/code&gt;인 “/dev/dri/card0”에 대응되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVPATH&lt;/code&gt;는 “/devices/pci0000:00/0000:00:0f.0/drm/card0”임을 알 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVPATH&lt;/code&gt;를 가지고도 아래와 같이 장치의 정보를 조회할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ udevadm info -a -p /sys/devices/pci0000:00/0000:00:0f.0/drm/card0
	
	Udevadm info starts with the device specified by the devpath and then
	walks up the chain of parent devices. It prints for every device
	found, all possible attributes in the udev rules key format.
	A rule to match, can be composed by the attributes of the device
	and the attributes from one single parent device.
	
	  looking at device '/devices/pci0000:00/0000:00:0f.0/drm/card0':
	    KERNEL==&quot;card0&quot;
	    SUBSYSTEM==&quot;drm&quot;
	    DRIVER==&quot;&quot;
	
	  looking at parent device '/devices/pci0000:00/0000:00:0f.0':
	    KERNELS==&quot;0000:00:0f.0&quot;
	    SUBSYSTEMS==&quot;pci&quot;
	    DRIVERS==&quot;vmwgfx&quot;
	    ATTRS{boot_vga}==&quot;1&quot;
	    ATTRS{broken_parity_status}==&quot;0&quot;
	    ATTRS{class}==&quot;0x030000&quot;
	    ATTRS{consistent_dma_mask_bits}==&quot;32&quot;
	    ATTRS{d3cold_allowed}==&quot;0&quot;
	    ATTRS{device}==&quot;0x0405&quot;
	    ATTRS{dma_mask_bits}==&quot;32&quot;
	    ATTRS{driver_override}==&quot;(null)&quot;
	    ATTRS{enable}==&quot;1&quot;
	    ATTRS{irq}==&quot;16&quot;
	    ATTRS{local_cpulist}==&quot;0-1&quot;
	    ATTRS{local_cpus}==&quot;00000000,00000000,00000000,00000003&quot;
	    ATTRS{msi_bus}==&quot;1&quot;
	    ATTRS{numa_node}==&quot;-1&quot;
	    ATTRS{subsystem_device}==&quot;0x0405&quot;
	    ATTRS{subsystem_vendor}==&quot;0x15ad&quot;
	    ATTRS{vendor}==&quot;0x15ad&quot;
	
	  looking at parent device '/devices/pci0000:00':
	    KERNELS==&quot;pci0000:00&quot;
	    SUBSYSTEMS==&quot;&quot;
	    DRIVERS==&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;libudev를-이용한-방법&quot;&gt;libudev를 이용한 방법&lt;/h2&gt;

&lt;p&gt;C코드에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;libudev&lt;/code&gt;를 이용하여 주 그래픽 카드에 대응되는 디바이스 노드를 찾을 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;weston&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;GNOME&lt;/code&gt;이 사용하는 컴포지터인 &lt;code class=&quot;highlighter-rouge&quot;&gt;mutter&lt;/code&gt;에 반영되어 있다. 이 부분은 1개 이상의 그래픽 카드가 장착된 경우를 고려한 것이다. 패치 전에는 “open(“/dev/dri/card0”)” 형태로 하드코딩하고 있었다. 패치는 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev_enumerate_*()&lt;/code&gt; 함수들을 이용해 “drm/card[0-9]*“에 매칭되는 디바이스 노드들을 순회하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;boot_vga&lt;/code&gt; 속성을 찾는다. 결국, 해당 속성을 갖는, 즉, 주 그래픽 카드의 정보를 담은 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev_device&lt;/code&gt; 객체(libudev가 제공하는 구조체)를 얻어낸다. 패치의 내용은 아래 링크에서 확인할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://lists.freedesktop.org/archives/wayland-devel/2012-October/006033.html&quot;&gt;https://lists.freedesktop.org/archives/wayland-devel/2012-October/006033.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mail.gnome.org/archives/commits-list/2015-September/msg01412.html&quot;&gt;https://mail.gnome.org/archives/commits-list/2015-September/msg01412.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;패치로 추가되는 함수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;find_primary_gpu()&lt;/code&gt;는 이름부터가 매우 직관적이다. 아래는 &lt;code class=&quot;highlighter-rouge&quot;&gt;weston&lt;/code&gt; 내부에서 해당 함수까지 이어지는 콜 스택의 일부이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;libweston/compositor-drm.c : find_primary_gpu&lt;/li&gt;
  &lt;li&gt;libweston/compositor-drm.c : drm_backend_create&lt;/li&gt;
  &lt;li&gt;libweston/compositor-drm.c : weston_backend_init(WL_EXPORT)&lt;/li&gt;
  &lt;li&gt;libweston/compositor.c : weston_load_module(WL_EXPORT)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;참고-weston_load_module&quot;&gt;참고, &lt;code class=&quot;highlighter-rouge&quot;&gt;weston_load_module()&lt;/code&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;두 문자열 “name”과 “entrypoint”를 입력받는다. 우선 “name”을 이용하여 “.libs/[name]”에 위치한 라이브러리를 동적으로 로딩한다. “name”은 로딩하려는 라이브러리의 파일 이름을 말한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;weston&lt;/code&gt;은 백엔드(backend)마다 로딩할 라이브러리의 파일 이름을 하드코딩으로 매핑하고 있다. “libweston/compositor.c”의 &lt;code class=&quot;highlighter-rouge&quot;&gt;backend_map[]&lt;/code&gt;이라는 문자열 배열이 그것이다. “[drm&lt;/td&gt;
      &lt;td&gt;fbdev&lt;/td&gt;
      &lt;td&gt;headless&lt;/td&gt;
      &lt;td&gt;rdp&lt;/td&gt;
      &lt;td&gt;wayland&lt;/td&gt;
      &lt;td&gt;x11]-backend.so”가 배열에 존재하고, 배열 참조를 위한 인덱스는 “libweston/compositor.h” 의 enum 타입인 “weston_compositor_backend”를 이용한다. 즉, “backend_map[WESTON_BACKEND_DRM]”은 “drm-backend.so”라는 문자열로 매핑된다. 이 문자열이 &lt;code class=&quot;highlighter-rouge&quot;&gt;weston_load_moudle()&lt;/code&gt; 함수의 첫 번째 인자인 “name”으로 전달되는 것이다. 백엔드의 종류와 각각에 매핑되는 문자열은 아래와 같다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// libweston/compositor.h
enum weston_compositor_backend {
	WESTON_BACKEND_DRM,
	WESTON_BACKEND_FBDEV,
	WESTON_BACKEND_HEADLESS,
	WESTON_BACKEND_RDP,
	WESTON_BACKEND_WAYLAND,
	WESTON_BACKEND_X11,
};
			
// libweston/compositor.c
static const char * const backend_map[] = {
	[WESTON_BACKEND_DRM] =		&quot;drm-backend.so&quot;,
	[WESTON_BACKEND_FBDEV] =	&quot;fbdev-backend.so&quot;,
	[WESTON_BACKEND_HEADLESS] =	&quot;headless-backend.so&quot;,
	[WESTON_BACKEND_RDP] =		&quot;rdp-backend.so&quot;,
	[WESTON_BACKEND_WAYLAND] =	&quot;wayland-backend.so&quot;,
	[WESTON_BACKEND_X11] =		&quot;x11-backend.so&quot;,
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;weston_load_module()&lt;/code&gt;은 인자로 받은 첫 번째 문자열인 “name”에 위치한 라이브러리를 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;dlopen()&lt;/code&gt;으로 로딩한다. 인자로 받은 두 번째 문자열인 “entrypoint”는 로딩한 라이브러리 내에서 호출할 함수의 이름을 의미한다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;dlsym&lt;/code&gt;을 이용하여 “entrypoint”, 즉, 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;weston_backend_init()&lt;/code&gt;의 주소를 찾아 호출한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;libdl&lt;/code&gt;은 이처럼 런타임에 라이브러리를 로딩하고 해당 라이브러리의 심볼들에 접근할 수 있게끔 도와준다. &lt;code class=&quot;highlighter-rouge&quot;&gt;weston_load_module()&lt;/code&gt;에 도달하기까지의 콜 스택은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;libweston/compositor.c : weston_load_module(WL_EXPORT)&lt;/li&gt;
  &lt;li&gt;libweston/compositor.c : weston_compositor_load_backend(WL_EXPORT)&lt;/li&gt;
  &lt;li&gt;compositor/main.c : weston_compositor_load_backend()&lt;/li&gt;
  &lt;li&gt;compositor/main.c : load_backend()&lt;/li&gt;
  &lt;li&gt;compositor/main.c : main()&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 15 Jan 2018 06:07:36 +0900</pubDate>
        <link>http://baek9.github.io/graphics/2018/01/15/%EA%B7%B8%EB%9E%98%ED%94%BD_%EC%B9%B4%EB%93%9C%EC%97%90_%EB%8C%80%EC%9D%91%EB%90%98%EB%8A%94_DRM_%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4_%EB%85%B8%EB%93%9C_%EC%B0%BE%EA%B8%B0.html</link>
        <guid isPermaLink="true">http://baek9.github.io/graphics/2018/01/15/%EA%B7%B8%EB%9E%98%ED%94%BD_%EC%B9%B4%EB%93%9C%EC%97%90_%EB%8C%80%EC%9D%91%EB%90%98%EB%8A%94_DRM_%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4_%EB%85%B8%EB%93%9C_%EC%B0%BE%EA%B8%B0.html</guid>
        
        
        <category>Graphics</category>
        
      </item>
    
      <item>
        <title>자바스크립트의 가비지컬렉션과 메모리 누수</title>
        <description>&lt;p&gt;크롬에 구현된 자바스크립트 엔진인 V8은 주기적인 가비지컬렉션을 수행한다고 알려져있다. 이와 관련한 정보를 검색하다가 Daniel Khan이 작성한 글을 그대로 따라해보고, 느낀 점을 정리해본다. 해당 글은 아래 링크에서 읽어볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.codeship.com/understanding-garbage-collection-in-node-js/&quot;&gt;Understanding Garbage Collection and Hunting Memory Leaks in Node.js&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;resident-set&quot;&gt;Resident Set&lt;/h2&gt;

&lt;p&gt;V8은 ‘Resident Set’이라는 구조로 메모리를 운용한다. JVM(Java Virtual Machine)이 메모리를 여러 세그먼트(Segment)로 나누는 것과 같이, Resident Set 구조에 의해 메모리는 Code, Stack, Heap 영역으로 나뉜다고 한다. 이 부분에 대해서는 좀 더 알아볼 필요가 있다.&lt;/p&gt;

&lt;h2 id=&quot;processmemoryusage&quot;&gt;process.memoryUsage()&lt;/h2&gt;

&lt;p&gt;Node.js 역시, 크롬과 마찬가지로 자바스크립트를 해석하기 위해 V8을 사용한다. Node.js는 &lt;code class=&quot;highlighter-rouge&quot;&gt;process.memoryUsage()&lt;/code&gt;라는 함수를 제공하는 것으로 보인다. Resident Set의 크기, 힙(Heap)의 크기, 사용중인 힙의 크기를 알 수 있는 것으로 보인다.&lt;/p&gt;

&lt;h2 id=&quot;garbage-collection&quot;&gt;Garbage Collection&lt;/h2&gt;

&lt;p&gt;기존의 C, C++에서는 프로그래머가 직접 메모리를 할당하고 해제해야하는 것과 달리 자바스크립트는 그럴 필요가 없다. 자바스크립트에서 사용되는 요소들 중, 사용되지 않는 요소들은 가비지컬렉션(Garbage Collection)에 의해 자동으로 메모리에서 제거되기 때문이다. 특히, V8은 성능적인 이유로 두 가지 가비지컬렉션을 제공한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Scavenge : 빠른, 빈번히, 그러나 불완전한 가비지 컬렉션&lt;/li&gt;
  &lt;li&gt;Mark-Sweep : 느린, 드물게, 그러나 완전한 가비지 컬렉션&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;memory-leak&quot;&gt;Memory Leak&lt;/h2&gt;

&lt;p&gt;특정 요소가 미래에 사용될 일이 없음에도 불구하고 메모리를 계속 점유 중인 상황을 ‘Memory Leak’이 발생했다고 한다. Memory Leak이 누적 발생하여 할당 가능한 메모리를 초과하는 순간, 프로세스는 죽어버릴 것이다.&lt;/p&gt;

&lt;h2 id=&quot;javascripts-scope&quot;&gt;JavaScript’s Scope&lt;/h2&gt;

&lt;p&gt;저자는 Memory Leak을 의도적으로 유도하는 코드를 제공한다. 본 글에 해당 코드를 수록하진 않는다. 해당 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수를 호출할수록 Memory Leak이 누적 발생한다. 해당 함수를 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;originalThing&lt;/code&gt;이 &lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;과 동일한 객체를 참조하는데 이 객체는 이전의 &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수 호출 시에 생성된 것이다. 현재의 &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수 호출 시에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;으로 하여금 새로이 생성된 객체를 참조하게 한다.&lt;/p&gt;

&lt;p&gt;전역 객체인 &lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수가 호출될 때마다 갱신되어 매번 새로이 생성된 객체를 참조한다. 따라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;originalThing&lt;/code&gt;, 즉, 이전의 &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수 호출에서 생성되었던 객체는 더 이상 사용될 일이 없으므로 메모리에서 제거되어야 한다 원래는, 가비지컬렉션에 의해서.&lt;/p&gt;

&lt;p&gt;그럼에도 불구하고 Memory Leak이 발생하는 원인은 &lt;code class=&quot;highlighter-rouge&quot;&gt;unused()&lt;/code&gt; 함수에 있다. 이를 이해하려면 자바스크립트의 유효 범위(scope)를 이해하여야 한다. 자바스크립트에서는 함수 안에 함수가, 즉, 함수가 중첩된 경우에 내부 함수가 외부 함수에 위치한 요소들을 참조할 수 있다. 결국, &lt;code class=&quot;highlighter-rouge&quot;&gt;replaceThing()&lt;/code&gt; 함수 내 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;의 메소드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;someMethod()&lt;/code&gt;는 외부 함수에 위치한 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;unused()&lt;/code&gt;를 참조할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;originalThing&lt;/code&gt;은 얼핏보기에 서로 연관이 없어 보인다. 하지만 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;theThing&lt;/code&gt;이 소유한 메소드 &lt;code class=&quot;highlighter-rouge&quot;&gt;someMethod()&lt;/code&gt;가 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;unused&lt;/code&gt;를 참조하고, 이는 다시 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;originalThing&lt;/code&gt;을 참조한다. 결국, &lt;code class=&quot;highlighter-rouge&quot;&gt;originalThing&lt;/code&gt;은 메모리에서 제거되지 못하고 Memory Leak이 발생한다.&lt;/p&gt;

&lt;h2 id=&quot;closure&quot;&gt;Closure&lt;/h2&gt;

&lt;p&gt;자바스크립트는 넓은 유효 범위 덕분에 C나 C++에서는 구현이 번거로웠던 클로저(Closure)를 손쉽게 구현할 수 있다. 클로저는 콜백으로 많이 이용된다. 넓은 유효 범위는 함수의 ‘호출’ 순간에도 ‘선언’ 당시의 문맥 속에서 동작하도록 하기 때문이다. 이 부분도 좀 더 알아볼 필요가 있다.&lt;/p&gt;

&lt;h2 id=&quot;inspector&quot;&gt;Inspector&lt;/h2&gt;

&lt;p&gt;웹 개발자들이 잘 알고 있을 개발자 도구, 즉, 웹 인스펙터(Inspector)는 의외로 많은 기능을 담고 있다. 본문에서는 Memory Leak이 발생한 것을 ‘인스펙터&amp;gt;프로파일(profile)&amp;gt;힙 스냅샷(Heap Snapshot)’ 기능으로 보여주고 있다. 인스펙터는 웹 개발자 뿐만 아니라, 브라우저 개발자에게도 상당한 도움되는 도구인 것 같다. 본문과 달리, 나는 인스펙터가 제공하는 자바스크립트 콘솔(console)로 Memory Leak이 발생한 것을 확인해보았다.&lt;/p&gt;

</description>
        <pubDate>Thu, 30 Nov 2017 08:24:45 +0900</pubDate>
        <link>http://baek9.github.io/javascript%20&%20v8/2017/11/30/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98_%EA%B0%80%EB%B9%84%EC%A7%80%EC%BB%AC%EB%A0%89%EC%85%98%EA%B3%BC_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%88%84%EC%88%98.html</link>
        <guid isPermaLink="true">http://baek9.github.io/javascript%20&%20v8/2017/11/30/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98_%EA%B0%80%EB%B9%84%EC%A7%80%EC%BB%AC%EB%A0%89%EC%85%98%EA%B3%BC_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%88%84%EC%88%98.html</guid>
        
        
        <category>JavaScript &amp; V8</category>
        
      </item>
    
      <item>
        <title>자바스크립트의 프로토타입 체인</title>
        <description>&lt;p&gt;자바스크립트(JavaScript)는 흔히 프로토타입(prototype) 기반의 언어라고 불린다. 프로토타입은 직역하면 원형이라는 의미이다. 자바스크립트로 생성한 모든 객체는 원형, 즉, 프로토타입 객체와 함께 쌍을 이룬다. 이러한 구조를 활용하면 C++을 이용한 객체 지향 프로그래밍(OOP : Object-Oriented Programming)에서 중요한 개념 중의 하나인 상속(inheritance)을 자바스크립트에서도 손쉽게 구현할 수 있다. 자바스크립트에서는 이를 ‘프로토타입 체인(prototype chain)’ 이라고 부른다. 프로토타입 체인을 이해하기 위해서는 우선 프로토타입 객체에 대한 감을 잡을 필요가 있다.&lt;/p&gt;

&lt;h2 id=&quot;객체의-생성&quot;&gt;객체의 생성&lt;/h2&gt;

&lt;p&gt;자바스크립트에서는 정의된 모든 함수(function)를 객체를 생성하기 위한 생성자로 활용할 수 있다. C++에서 클래스 이름과 동일한 이름을 가진 멤버 함수가 생성자로 지정되는 것과는 상당히 다른 부분이다. 자바스트립트에서는 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt;라는 함수를 제공하고 있으며, &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;라는 연산자를 이용하여 다음과 같이 객체를 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var a = new Object();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;또한, 이러한 방법말고도 객체 리터럴 표기법(Object literal notation)을 이용하여 객체를 생성할 수도 있다. JSON(JavaScript Object Notation)과 유사하지만 차이점이 존재한다. 객체 리터럴 표기법을 이용하여 다음과 같이 객체를 생성할 수 있으며, 바로 위의 코드와 동일하다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var a = {}&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;객체&quot;&gt;객체&lt;/h2&gt;

&lt;p&gt;자바스크립트의 자료형에는 null, undefined, boolean, number, string, symbol, object의 7가지가 존재한다. 앞의 6가지는 이름만으로 어떤 것을 의미하는지 명백히 파악할 수 있는 만큼 기본 자료형(primitive)으로 분류된다. 기본 자료형이 아닌 모든 것들은 전부 object 타입, 즉, 객체이다. 앞서 살펴본 것처럼 JSON과 유사한 객체 리터럴 표기법으로 객체가 생성된다는 점으로 미루어 보아 객체는 키와 값의 쌍들로 구성된다고 어렴풋이 추측해 볼 수 있겠다. 다만, 키라는 용어 대신 속성(property)이라는 이름을 사용한다. 자바스크립트 객체는 속성과 값의 쌍으로 구성된다.&lt;/p&gt;

&lt;h2 id=&quot;객체-1&quot;&gt;객체&lt;/h2&gt;

&lt;p&gt;기본 자료형이 아닌 모든 것들은 객체이므로 함수도 객체이다. 따라서 앞에서 언급한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt; 힘수도 객체이다. 객체로 객체를 만든 것이다. C나 C++을 주로 다뤘다면 충격적으로 다가오는 사실 중의 하나일 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;함수-객체&quot;&gt;함수 객체&lt;/h2&gt;

&lt;p&gt;앞서 설명했듯이 객체는 프로퍼티와 값의 쌍으로 구성되며, 자바스크립트의 모든 자료형이 값에 대입될 수 있다. 따라서 객체인 함수, 즉, 함수 객체도 속성과 값의 쌍을 여럿 가질 수 있다. 함수 객체는 특별히 &lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt; 이라는 속성을 가지는데, 이는 해당 객체의 프로토타입 객체를 가리킨다. 앞서도 언급했둣이 자바스크립트의 모든 객체는 프로토타입 객체와 한 쌍을 이룬다. 즉, 아래와 같이 함수를 정의하는 순간,&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;function funcA () {}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;object 타입인 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA&lt;/code&gt;가 생성되며, 이 객체는 함수 객체의 특징 상 &lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;이라는 속성을 갖는다. 특정 객체의 속성을 참조하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;을 이용하면 된다. 즉, 아래와 같이 함수 객체의 프로토타입 객체를 참조할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;funcA.prototype&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로토타입-객체&quot;&gt;프로토타입 객체&lt;/h2&gt;

&lt;p&gt;함수 객체가 생성되는 순간에 프로토타입 객체가 함께 생성된다. 이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt; 속성으로 참조할 수 있다. 프로토타입 객체도 객체이므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt; 함수 또는 객체 리터럴 표기법으로 생성하는 것과 그 원리는 다를 바 없다. 다만, 일반적인 객체들과 다른 점은 개발자가 모르는 사이에 생성된다는 점이다. 따라서, 앞서 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA&lt;/code&gt;를 생성하는 순간 아래의 코드가 암묵적으로 수행되는 것으로 이해해 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var p = new Object();
p.constructor = funcA;
funcA.prototype = p;
p.__proto__ = Object.prototype;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드로 이해를 해보면, 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA&lt;/code&gt;가 생성될 때 프로토타입 객체가 생성된다. 함수 객체 입장에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;이라는 속성으로 프로토타입 객체를 참조할 수 있다. 한편, 프로토타입 객체는 두 가지 속성, &lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;를 가진다. 전자는 다시 역으로 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA&lt;/code&gt;를 가리킨다. 여기까지가 함수 객체와 생성되는 프로토타입 객체의 생성 과정과 실체에 대한 내용이다.&lt;/p&gt;

&lt;h2 id=&quot;프로토타입-체인&quot;&gt;프로토타입 체인&lt;/h2&gt;

&lt;p&gt;프로토타입 객체에 대하여 한 가지 설명하지 않은 것은, 프로토타입 객체가 가진 두 가지 속성 중 하나인 &lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 속성이다. 이 속성은 함수 객체를 제외한 나머지, 그러니까, 프로토타입 객체를 포함한 일반 객체들이 생성될 때, 생성의 원인이 되는 객체의 프로토타입을 참조하기 위한 속성이다. 바로 앞 예제에서 프로토타입 객체 생성의 ‘원인’인 객체는 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt;이므로, 바로 이 함수 객체와 쌍을 이루는 프로토타입 객체를 참조한다는 것이다. 결국, 다음의 등식은 참이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;funcA.prototype.__proto__ === Object.prototype&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;앞서, 모든 함수는 일반 객체를 생성하기 위한 생성자로서 활용할 수 있다고 했다. 따라서 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt;를 이용해서 또다른 객체를 만들 수 있는 것처럼, 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA()&lt;/code&gt;를 이용해서 다음과 같이 또다른 객체를 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var objA = new funcA()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;앞서 설명한 것처럼 일반 객체인 &lt;code class=&quot;highlighter-rouge&quot;&gt;objA&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;라는 속성을 가진다. 해당 객체의 생성은 함수 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;funcA()&lt;/code&gt;이 원인이므로 다음의 등식은 참이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objA.__proto__ === funcA.prototype&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;두 등식을 나란히 놓고보면,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;objA.__proto__ === funcA.prototype
funcA.prototype.__proto__ === Object.prototype
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 속성으로 인해 일반 객체를 시작으로 두 개의 프로토타입 객체까지 연달아 연결된 것이다. 바로 이것을 프로토타입 체인이라고 한다. 이러한 이유로 자바스크립트 체인을 이용하면 OOP의 중요한 개념 중의 하나인 상속을 구현할 수 있다. 같은 방법으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;objB&lt;/code&gt; 객체를 만든다면, ‘objA`와 다른 객체이지만 동일한 프로토타입 객체를 참조한다. 이러한 특징을 이용하면 프로토타입 객체에 임의의 속성을 생성하여 C++에서의 클래스 변수처럼 사용할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 26 Nov 2017 07:12:24 +0900</pubDate>
        <link>http://baek9.github.io/javascript%20&%20v8/2017/11/26/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98_%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EC%B2%B4%EC%9D%B8.html</link>
        <guid isPermaLink="true">http://baek9.github.io/javascript%20&%20v8/2017/11/26/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98_%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EC%B2%B4%EC%9D%B8.html</guid>
        
        
        <category>JavaScript &amp; V8</category>
        
      </item>
    
      <item>
        <title>인텔 에디슨 보드 최초 세팅하기</title>
        <description>&lt;p&gt;인텔 에디슨(edison) 보드는 현재는 단종된 제품이다. 후속인 줄(Joule) 보드 역시 단종되었다. 두 제품은 IoT(Internet of things)를 겨냥하여 만들어진 만큼, 인텔이 이 시장에서 발을 빼고 있다는 의견들이 많다. 어쨌든, 인텔은 IoT, 웨어러블(Wearable)에 부합하도록 에디슨 보드를 극도로 소형화 하였다. 더 이상 지원되지 않는 보드이지만 라즈베리파이(RPi : Raspberry Pi)보다도 작은 크기, 그러나 부족하지 않은 성능에 매력을 느껴 사용해 보았다. 에디슨 보드의 세팅 방법은 인텔의 홈페이지에 상세히 나와 있다. 본 글은 세팅 중에 마주쳤던 문제점, 특히 플래싱(flashing)에 대한 내용을 담았다.&lt;/p&gt;

&lt;h2 id=&quot;breakout-board&quot;&gt;Breakout board&lt;/h2&gt;

&lt;p&gt;에디슨 보드는 소형이므로 ‘Breakout board’에 결합하여야 개발을 진행할 수 있다. 결합의 도움으로 2개의 USB 포트를 통해 에디슨 보드를 제어할 수 있다. 에디슨 보드에 새겨진 인텔 로고가 바로 보이는 상태에서 하단 USB 포트는 5V의 전원 공급 및 플래시 저장소 마운트를 담당한다. 상단 USB 포트는 에디슨 보드와의 시리얼(Serial) 통신을 담당한다.&lt;/p&gt;

&lt;h2 id=&quot;setup-toolno-more-support&quot;&gt;Setup tool(NO MORE SUPPORT)&lt;/h2&gt;

&lt;p&gt;대부분의 개발 보드가 그렇듯이 최초에는 커널과 루트 파일 시스템(rootfs)을 보드에 탑재하여야 한다. 이를 플래싱(flashing)이라고 한다. 인텔 홈페이지를 통해 커널 이미지와 함께 플래싱을 위한 GUI 도구인 ‘Setup tool’이 제공된다. 그런데 Setup tool은 최신 OSX 및 윈도우즈10을 지원하지 않는다. OSX에서는 플래싱은 되지만 슈퍼블록(Superblock)이 깨지어 온전히 플래싱되진 않는다. 따라서, 고전적인 방법대로 시리얼 통신을 통해 플래싱을 수행하여야 했다. 기존 보드들의 플래싱 방법에서 크게 벗어나진 않는다.&lt;/p&gt;

&lt;h2 id=&quot;make-edison-ready-to-flashing&quot;&gt;Make edison ready to flashing&lt;/h2&gt;

&lt;p&gt;우선, 에디슨 보드와 시리얼 통신을 하기 위해서는 상단 USB를 연결하여야 한다. 이후, 아래와 같은 절차를 밟는다. OSX에서는 터미널 상에서 다음과 같이 입력한다. 그러나, 결과적으로는 OSX에서의 플래싱은 실패하여 윈도우즈에서 플래싱을 수행했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ls /dev/cu.usbserial-*
screen /dev/cu.usbserial-XXXXXXXX 115200 -L
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;윈도우즈에서는 Putty라는 원격 터미널 접속용 도구를 이용하면 된다. 접속에 필요한 포트 번호는 장치관리자에서 확인할 수 있고, 전송 속도는 115200으로 설정하면 된다.&lt;/p&gt;

&lt;p&gt;시리얼 통신이 연결된 이후, 에디슨 보드를 재부팅하여 부팅 중에 아무 키나 입력하면 소형 부트로더인 &lt;code class=&quot;highlighter-rouge&quot;&gt;u-boot&lt;/code&gt;의 쉘을 획득할 수 있다. 이 쉘에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;run do_flash&lt;/code&gt;를 입력한다. 직후부터 에디슨 보드는 호스트로부터의 플래싱을 기다린다.&lt;/p&gt;

&lt;h2 id=&quot;flashing&quot;&gt;Flashing&lt;/h2&gt;

&lt;p&gt;앞서 다운로드 받은 커널 이미지의 압축을 풀면 이미지와 함께 몇 가지 실행 가능한 스크립트들을 확인할 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;flashall.sh&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;flashall.bat&lt;/code&gt;이다. 전자는 OSX 또는 리눅스를 위한, 후자는 윈도우즈를 위한 플래싱 스크립트이다. OSX에서는 이 스크립트가 잘 실행되지 않았던 반면, 윈도우즈에서는 잘 동작하였다. 단, 윈도우즈의 경우에 커널 이미지와 동일한 위치에 &lt;code class=&quot;highlighter-rouge&quot;&gt;dfu-util.exe&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;libusb-1.0.dll&lt;/code&gt;을 삽입해두어야 한다. 두 파일은 시리얼 통신을 통한 플래싱 방법을 자세히 소개한 아래의 글을 통해 다운로드 받을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://software.intel.com/en-us/flashing-firmware-on-your-intel-edison-board-windows&quot;&gt;Flashing the OS Image on your Board with Windows&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이후, 윈도우 쉘에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;flashall.bat&lt;/code&gt;를 실행하면 플래싱이 진행된다. 상당한 시간이 소요된다. 아래 그림은 플래싱이 진행된 최종 스크린 샷 이다.&lt;/p&gt;

</description>
        <pubDate>Fri, 29 Aug 2014 23:34:25 +0900</pubDate>
        <link>http://baek9.github.io/embedded/2014/08/29/%EC%9D%B8%ED%85%94_%EC%97%90%EB%94%94%EC%8A%A8_%EB%B3%B4%EB%93%9C_%EC%B5%9C%EC%B4%88_%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0.html</link>
        <guid isPermaLink="true">http://baek9.github.io/embedded/2014/08/29/%EC%9D%B8%ED%85%94_%EC%97%90%EB%94%94%EC%8A%A8_%EB%B3%B4%EB%93%9C_%EC%B5%9C%EC%B4%88_%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0.html</guid>
        
        
        <category>embedded</category>
        
      </item>
    
  </channel>
</rss>
