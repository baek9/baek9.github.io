<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Playing with JSON in Chromium | code(evening);</title><meta name=keywords content="Chromium,JSON"><meta name=description content="#Chromium #JSON
다른 포스트에서도 언급했거나 언급하겠지만, 크로미움은 그 자체로 매우 풍부한 라이브러리 집합이다. 예를 들면, Thread, GURL 클래스를 이용하면 손쉽게 스레드를 만들고 관리할 수 있으며, URL도 입맛대로 다룰 수 있다. (scheme만 따로 추출하려고 굳이 파싱하지 않아도 되는) 이 밖에도 유용한 클래스들이 많이 존재하며, 이들은 크로미움의 base 네임스페이스에 존재한다.
크로미움은 웹 브라우저이므로 당연히 JSON(JavaScript Object Notation)을 처리하기 위한 모듈이 존재할 것이다. 아니, 존재하여야만 한다. 실제로, base 네임스페이스 아래에 JSONReader 클래스가 존재한다. 물론, libjson-c나 libjsoncpp와 같은 라이브러리를 활용하는 옵션도 있겠지만, 크로미움 개발자라면 굳이 이를 활용할 필요가 없겠다."><meta name=author content="baek9"><link rel=canonical href=https://baek9.github.io/2018/03/playing-with-json-in-chromium/><meta name=google-site-verification content="jxplsfLcADRts9fVC-PBsYD4NFNGHEMo08_Lj3HzSts"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.1b2afdf7fcaa8622a5c1cc704d5ca2da92c173ba5ed24382df9c72b6ca594315.css integrity="sha256-Gyr99/yqhiKlwcxwTVyi2pLBc7pe0kOC35xytspZQxU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://baek9.github.io/logo_squared.png><link rel=icon type=image/png sizes=16x16 href=https://baek9.github.io/logo_squared.png><link rel=icon type=image/png sizes=32x32 href=https://baek9.github.io/logo_squared.png><link rel=apple-touch-icon href=https://baek9.github.io/logo_squared.png><link rel=mask-icon href=https://baek9.github.io/logo_squared.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://baek9.github.io/2018/03/playing-with-json-in-chromium/><link rel=alternate hreflang=en href=https://baek9.github.io/en/2018/03/playing-with-json-in-chromium/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link href=//cdn.jsdelivr.net/gh/wan2land/d2coding/d2coding-full.css rel=stylesheet><link href=//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css rel=stylesheet type=text/css><link href=https://hangeul.pstatic.net/hangeul_static/css/nanum-square.css rel=stylesheet><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-108486276-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Playing with JSON in Chromium"><meta property="og:description" content="#Chromium #JSON
다른 포스트에서도 언급했거나 언급하겠지만, 크로미움은 그 자체로 매우 풍부한 라이브러리 집합이다. 예를 들면, Thread, GURL 클래스를 이용하면 손쉽게 스레드를 만들고 관리할 수 있으며, URL도 입맛대로 다룰 수 있다. (scheme만 따로 추출하려고 굳이 파싱하지 않아도 되는) 이 밖에도 유용한 클래스들이 많이 존재하며, 이들은 크로미움의 base 네임스페이스에 존재한다.
크로미움은 웹 브라우저이므로 당연히 JSON(JavaScript Object Notation)을 처리하기 위한 모듈이 존재할 것이다. 아니, 존재하여야만 한다. 실제로, base 네임스페이스 아래에 JSONReader 클래스가 존재한다. 물론, libjson-c나 libjsoncpp와 같은 라이브러리를 활용하는 옵션도 있겠지만, 크로미움 개발자라면 굳이 이를 활용할 필요가 없겠다."><meta property="og:type" content="article"><meta property="og:url" content="https://baek9.github.io/2018/03/playing-with-json-in-chromium/"><meta property="og:image" content="https://baek9.github.io/logo_extended.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-03-18T22:00:00+00:00"><meta property="article:modified_time" content="2018-03-18T22:00:00+00:00"><meta property="og:site_name" content="code(evening); - 늦은 밤 개발 일기"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://baek9.github.io/logo_extended.png"><meta name=twitter:title content="Playing with JSON in Chromium"><meta name=twitter:description content="#Chromium #JSON
다른 포스트에서도 언급했거나 언급하겠지만, 크로미움은 그 자체로 매우 풍부한 라이브러리 집합이다. 예를 들면, Thread, GURL 클래스를 이용하면 손쉽게 스레드를 만들고 관리할 수 있으며, URL도 입맛대로 다룰 수 있다. (scheme만 따로 추출하려고 굳이 파싱하지 않아도 되는) 이 밖에도 유용한 클래스들이 많이 존재하며, 이들은 크로미움의 base 네임스페이스에 존재한다.
크로미움은 웹 브라우저이므로 당연히 JSON(JavaScript Object Notation)을 처리하기 위한 모듈이 존재할 것이다. 아니, 존재하여야만 한다. 실제로, base 네임스페이스 아래에 JSONReader 클래스가 존재한다. 물론, libjson-c나 libjsoncpp와 같은 라이브러리를 활용하는 옵션도 있겠지만, 크로미움 개발자라면 굳이 이를 활용할 필요가 없겠다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://baek9.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Playing with JSON in Chromium","item":"https://baek9.github.io/2018/03/playing-with-json-in-chromium/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Playing with JSON in Chromium","name":"Playing with JSON in Chromium","description":"#Chromium #JSON\n다른 포스트에서도 언급했거나 언급하겠지만, 크로미움은 그 자체로 매우 풍부한 라이브러리 집합이다. 예를 들면, Thread, GURL 클래스를 이용하면 손쉽게 스레드를 만들고 관리할 수 있으며, URL도 입맛대로 다룰 수 있다. (scheme만 따로 추출하려고 굳이 파싱하지 않아도 되는) 이 밖에도 유용한 클래스들이 많이 존재하며, 이들은 크로미움의 base 네임스페이스에 존재한다.\n크로미움은 웹 브라우저이므로 당연히 JSON(JavaScript Object Notation)을 처리하기 위한 모듈이 존재할 것이다. 아니, 존재하여야만 한다. 실제로, base 네임스페이스 아래에 JSONReader 클래스가 존재한다. 물론, libjson-c나 libjsoncpp와 같은 라이브러리를 활용하는 옵션도 있겠지만, 크로미움 개발자라면 굳이 이를 활용할 필요가 없겠다.","keywords":["Chromium","JSON"],"articleBody":"#Chromium #JSON\n다른 포스트에서도 언급했거나 언급하겠지만, 크로미움은 그 자체로 매우 풍부한 라이브러리 집합이다. 예를 들면, Thread, GURL 클래스를 이용하면 손쉽게 스레드를 만들고 관리할 수 있으며, URL도 입맛대로 다룰 수 있다. (scheme만 따로 추출하려고 굳이 파싱하지 않아도 되는) 이 밖에도 유용한 클래스들이 많이 존재하며, 이들은 크로미움의 base 네임스페이스에 존재한다.\n크로미움은 웹 브라우저이므로 당연히 JSON(JavaScript Object Notation)을 처리하기 위한 모듈이 존재할 것이다. 아니, 존재하여야만 한다. 실제로, base 네임스페이스 아래에 JSONReader 클래스가 존재한다. 물론, libjson-c나 libjsoncpp와 같은 라이브러리를 활용하는 옵션도 있겠지만, 크로미움 개발자라면 굳이 이를 활용할 필요가 없겠다. 본 포스트에는 크로미움 내에서 JSON을 다루는 방법을 담았다.\n1. Open and read file ¶ 처리하고자 하는 대상은 파일 형태로 존재할 수도 있고, 네트워크로 받아와 바이트 스트림 형태로 존재할 수도 있다. 파일 형태도 결국은 처리를 위해서 바이트 스트림 형태로 변환해야 하므로 전자의 경우를 보겠다.\n크로미움은 심지어 파일 경로를 처리하는 클래스까지 갖고 있다. 해당 클래스는 FilePath이다. 굳이 파일 경로를 처리하는 클래스가 필요한 지 의문이 들 수 있지만, 플랫폼마다 파일 경로를 구성하는 규칙이 다르기 때문에라도 매우 유용하고 중요한, 생각보다 복잡한 클래스이다. 처리하고자 하는 파일이 test.json이고, 파일 경로가 “/path/to/file/test.json\"이라면 다음과 같이 FilePath 객체를 생성할 수 있다.\nbase::FilePath json_path(\"/path/to/file/test.json\"); 위 코드로 json_path라는 FilePath 객체가 생성된다. 이제 이 객체를 이용하여 test.json을 읽고, 그 내용을 바이트 스트림 형태로 가져와야 한다. 이 작업은 ReadFileToString() 함수를 이용하여 아래와 같이 수행할 수 있다.\nstd::string json_string; base::ReadFileToString(json_path, \u0026json_string); 위 코드로 test.json의 내용이 문자열 객체인 json_string에 저장된다.\n2. Parse JSON and Ready to play with it ¶ json_string은 test.json의 내용을 바이트 스트림으로 저장하고 있을 뿐인 문자열 객체에 불과하다. 이 문자열을 JSON 문법에 맞추어 취급하기 쉬운 형태로 파싱하여야 한다. 생각만해도 번거로운 이 작업은 base 네임스페이스 내 JSONReader 클래스의 멤버 함수인 Read()로 쉽게 처리할 수 있다. static 함수이므로 다음과 같이 활용할 수 있다.\nstd::unique_ptr json_structure; json_structure = base::JSONReader::Read(json_str); 위 코드로 json_structure라는 Value 객체가 생성된다. 이를 이용하여 test.json 내의 모든 키 값들을 추출할 수 있다.\n3. Getting a dictionary from a JSON ¶ JSON은 다음의 두 개의 구조를 바탕으로 구성된다. JSON 공식 홈페이지에 두 구조에 대한 간략한 설명이 존재한다.\nCollection name/value pairs. In various languages this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array. Ordered list of values realized as an array, vector, list, or sequence. JSON은 Collection과 Ordered list로 구성된다. 따라서, JSON으로부터 이 두 구조를 얻어낼 수 있다는 것은 곧, JSON을 완벽하게 활용할 수 있다는 것이다. Collection과 Ordered list를 구현하는 방법은 언어에 따라 다르다. 크로미움에서는 각각 Dictionary와 List로 표현한다. 그리고, base 네임스페이스에는 Value 클래스를 상속받는 DictionaryValue와 ListValue라는 클래스가 존재한다. 뭔가 감이 오기 시작한다. 더 진행하기에 앞서서, test.json의 내용이 다음과 같다고 가정하자.\n{ \"key1\" : { \"key11\" : \"value11\", \"key12\" : [ \"element121\", \"element122\" ] } JSON 전쳬가 하나의 Collection, 즉, Dictionary이다. 따라서 앞서 파싱하여 얻어낸 Value 객체인 json_structure로부터 DictionaryValue 객체를 얻어내야 한다. 그래야만 key11의 값인 “value11\"과 Ordered list인 key12가 포함하는 값들인 “element121”, “element122\"를 추출할 수 있을 것이다. DictionaryValue 객체를 얻어내기 위해서는 DictionaryValue 클래스의 From() 함수를 이용하면 된다. static 함수이므로 다음과 같이 활용할 수 있다.\nstd::unique_ptr json_dictionary; json_dictionary = base::DictionaryValue::From(json_structure); 위 코드로 json_dictionary라는 DictionaryValue 객체를 얻어낼 수 있다.\n4. Getting a value which type is “string” from a dictionary ¶ 크로미움에서만 그런지는 모르겠지만 “.”을 이용하여 특정 키의 경로를 표현할 수 있다. 예를 들어, Key11의 주소는 “key1.key11\"이다. 이 경로를 이용하여 해당 키의 값을 추출할 수 있다. key11에 대응되는 값의 타입은 문자열이므로 DictionaryValue 클래스의 GetString() 함수를 아래와 같이 활용할 수 있다.\nstd::string key11_value; json_dictionary-\u003eGetString(\"key1.key11\", \u0026key11_value); 5. Getting a list from a dictionary ¶ key12는 대괄호로 둘러쌓인 Ordered list, 즉, List이다. 따라서 이번에는 DictionaryValue 객체로부터 std::string이 아닌, ListValue객체를 추출해야 한다. 이를 위해 DictionaryValue 클래스의 GetList() 함수를 아래와 같이 활용할 수 있다.\nbase::ListValue* key12_list; json_dictionary-\u003eGetList(\"key1.key12\", \u0026key12_list); 6. Iterate and getting a value which type is “string” from a list ¶ 앞서 얻어낸 ListValue 객체인 key12_list의 원소들을 순회하여 Ordered list인 key12의 모든 원소들을 추출할 수 있다. DictionaryValue, ListValue 클래스는 Value 클래스를 상속받는다. ListValue의 경우에는 원소들이 부모 클래스인 Value가 정의하는 멤버 변수, ListStorage에 저장된다. 아래와 같은 연쇄 대입 체인에 따르면,\n// base/values.h // https://cs.chromium.org/chromium/src/base/values.h?rcl=029daddc376494ee36c5d81cc51a5ade45002fb6\u0026l=589 class ListValue : public Value { using const_iterator = ListStorage::const_iterator; } // base/values.h // https://cs.chromium.org/chromium/src/base/values.h?rcl=029daddc376494ee36c5d81cc51a5ade45002fb6\u0026l=85 ListStorage = std::vector; ListStorage는 결국 std::vector 객체이다. 즉, std::vector 객체를 순회하는 방법을 그대로 활용하여 원소들을 순회할 수 있다.\nListValue::const_iterator == std::vector::const_iterator\n순회 중에 방문한 원소들의 타입은 무엇일까? 타입을 알아야 값을 추출할 수 있다. 위 등식에서도 알 수 있듯이, iterator 또는 const_iterator에 의해 참조하는 각 원소들은 base::Value* 또는 const base::Value*이다. 한편, Value 객체의 값은 멤버 함수인 GetString()으로 얻어낼 수 있다.(키 값의 타입이 문자열인 경우라면) 아래가 그 예제다.\nfor(base::ListValue::const_iterator it = key12_list-\u003ebegin(); it != key12_list-\u003eend(); ++it) { std::string key12_string() it-\u003eGetString(); } Full example ¶ test.json으로부터 모든 값을 추출하는 전체 예제 코드는 다음과 같다.\nbase::FilePath json_path(\"/path/to/file/test.json\"); std::string json_string; std::unique_ptr json_structure; std::unique_ptr json_dictionary; std::string key11_value; base::ListValue* key12_list; base::ReadFileToString(json_path, \u0026json_string); json_structure = base::JSONReader::Read(json_str); json_dictionary = base::DictionaryValue::From(json_structure); json_dictionary-\u003eGetString(\"key1.key11\", \u0026key11_value); json_dictionary-\u003eGetList(\"key1.key12\", \u0026key12_list); for(base::ListValue::const_iterator it = key12_list-\u003ebegin(); it != key12_list-\u003eend(); ++it) { std::string key12_string() it-\u003eGetString(); } ","wordCount":"778","inLanguage":"ko","datePublished":"2018-03-18T22:00:00Z","dateModified":"2018-03-18T22:00:00Z","author":{"@type":"Person","name":"baek9","url":"https://baek9.github.io/"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://baek9.github.io/2018/03/playing-with-json-in-chromium/"},"publisher":{"@type":"Organization","name":"code(evening);","logo":{"@type":"ImageObject","url":"https://baek9.github.io/logo_squared.png"}}}</script></head><body id=top><style>.button-62{background:linear-gradient(to bottom right,#EF4765,#FF9A5A);border:0;border-radius:12px;cursor:pointer;display:inherit;font-family:-apple-system,system-ui,segoe ui,Roboto,Helvetica,Arial,sans-serif;font-size:16px;font-weight:500;line-height:2.5;outline:transparent;padding:0 1rem;text-align:center;text-decoration:none;transition:box-shadow .2s ease-in-out;user-select:none;-webkit-user-select:none;touch-action:manipulation;white-space:nowrap}.button-62:not([disabled]):focus{box-shadow:0 0 .25rem rgba(0,0,0,.5),-.125rem -.125rem 1rem rgba(239,71,101,.5),.125rem .125rem 1rem rgba(255,154,90,.5)}.button-62:not([disabled]):hover{box-shadow:0 0 .25rem rgba(0,0,0,.5),-.125rem -.125rem 1rem rgba(239,71,101,.5),.125rem .125rem 1rem rgba(255,154,90,.5)}</style><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=social-icons><a href=https://baek9.github.io/ accesskey=h title="늦은 밤 개발 일기 (Alt + H)"><img src=https://baek9.github.io/logo.png style=border-radius:5px;padding:6px;background:#fff alt=logo aria-label=logo height=45>늦은 밤 개발 일기</a></div><div class="social-icons logo-switches"><ul id=menu><li><div style=vertical-align:center;line-height:16px><a href=https://linkedin.com/in/thnam target=_blank rel="noopener noreferrer me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></div></li><li><div style=vertical-align:center;line-height:16px><a href=https://twitter.com/thnam_ target=_blank rel="noopener noreferrer me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></li><li><div style=vertical-align:center;line-height:16px><a href=https://github.com/baek9 target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></li><li><div style=vertical-align:center;line-height:16px><a href=https://baek9.github.io/index.xml target=_blank rel="noopener noreferrer me" title=Rss><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div></li></ul></div></div><ul id=menu><li><a href=https://baek9.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://baek9.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://baek9.github.io/about_me/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main style=min-height:unset><style>.post-title{margin-bottom:2px;font-size:30px}.post-content h2{font-size:25px}.entry-footer{font-size:10px}</style><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://baek9.github.io/>홈</a>&nbsp;»&nbsp;<a href=https://baek9.github.io/posts/>Posts</a></div><h1 class=post-title>Playing with JSON in Chromium</h1><div class=post-meta><span title='2018-03-18 22:00:00 +0000 UTC'>3월 18, 2018</span>&nbsp;·&nbsp;baek9&nbsp;|&nbsp;번역:<ul class=i18n_list><li><a href=https://baek9.github.io/en/2018/03/playing-with-json-in-chromium/>🇺🇸</a></li></ul></div></header><style>#figmask{width:100%}#figmask{position:relative}#figmask:after{width:100%;content:'';display:block;position:absolute;top:0;left:0;background:linear-gradient(to top,var(--entry) 0,transparent 5em);height:100%}</style><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-open-and-read-file>1. Open and read file</a></li><li><a href=#2-parse-json-and-ready-to-play-with-it>2. Parse JSON and Ready to play with it</a></li><li><a href=#3-getting-a-dictionary-from-a-json>3. Getting a dictionary from a JSON</a></li><li><a href=#4-getting-a-value-which-type-is-string-from-a-dictionary>4. Getting a value which type is &ldquo;string&rdquo; from a dictionary</a></li><li><a href=#5-getting-a-list-from-a-dictionary>5. Getting a list from a dictionary</a></li><li><a href=#6-iterate-and-getting-a-value-which-type-is-string-from-a-list>6. Iterate and getting a value which type is &ldquo;string&rdquo; from a list</a></li><li><a href=#full-example>Full example</a></li></ul></nav></div></details></div><style>.highlight{margin-bottom:5.5em;font-family:poppins,sans-serif;font-weight:700;text-decoration:none;background:linear-gradient(to right,#64ffff,#64ffff),linear-gradient(to right,red,#4378ff,#64ffff);background-size:100% 3px,0 3px;background-position:100% 100%,0 100%;background-repeat:no-repeat;transition:background-size 400ms}</style><div class=post-content><p>#Chromium #JSON</p><p>다른 포스트에서도 언급했거나 언급하겠지만, 크로미움은 그 자체로 매우 풍부한 라이브러리 집합이다. 예를 들면, <code>Thread</code>, <code>GURL</code> 클래스를 이용하면 손쉽게 스레드를 만들고 관리할 수 있으며, URL도 입맛대로 다룰 수 있다. (scheme만 따로 추출하려고 굳이 파싱하지 않아도 되는) 이 밖에도 유용한 클래스들이 많이 존재하며, 이들은 크로미움의 <code>base</code> 네임스페이스에 존재한다.</p><p>크로미움은 웹 브라우저이므로 당연히 JSON(JavaScript Object Notation)을 처리하기 위한 모듈이 존재할 것이다. 아니, 존재하여야만 한다. 실제로, <code>base</code> 네임스페이스 아래에 <code>JSONReader</code> 클래스가 존재한다. 물론, <code>libjson-c</code>나 <code>libjsoncpp</code>와 같은 라이브러리를 활용하는 옵션도 있겠지만, 크로미움 개발자라면 굳이 이를 활용할 필요가 없겠다. 본 포스트에는 크로미움 내에서 JSON을 다루는 방법을 담았다.</p><div class=post-entry style=background:unset;border:unset><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8701780565311862"></script>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8701780565311862 data-ad-slot=3363952713></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><h2 id=1-open-and-read-file>1. Open and read file <a href=#1-open-and-read-file>¶</a><a hidden class=anchor aria-hidden=true href=#1-open-and-read-file>#</a></h2><p>처리하고자 하는 대상은 파일 형태로 존재할 수도 있고, 네트워크로 받아와 바이트 스트림 형태로 존재할 수도 있다. 파일 형태도 결국은 처리를 위해서 바이트 스트림 형태로 변환해야 하므로 전자의 경우를 보겠다.</p><p>크로미움은 심지어 파일 경로를 처리하는 클래스까지 갖고 있다. 해당 클래스는 <code>FilePath</code>이다. 굳이 파일 경로를 처리하는 클래스가 필요한 지 의문이 들 수 있지만, 플랫폼마다 파일 경로를 구성하는 규칙이 다르기 때문에라도 매우 유용하고 중요한, 생각보다 복잡한 클래스이다. 처리하고자 하는 파일이 test.json이고, 파일 경로가 &ldquo;/path/to/file/test.json"이라면 다음과 같이 <code>FilePath</code> 객체를 생성할 수 있다.</p><pre tabindex=0><code>base::FilePath json_path(&#34;/path/to/file/test.json&#34;);
</code></pre><p>위 코드로 json_path라는 <code>FilePath</code> 객체가 생성된다. 이제 이 객체를 이용하여 test.json을 읽고, 그 내용을 바이트 스트림 형태로 가져와야 한다. 이 작업은 <code>ReadFileToString()</code> 함수를 이용하여 아래와 같이 수행할 수 있다.</p><pre tabindex=0><code>std::string json_string;
base::ReadFileToString(json_path, &amp;json_string);
</code></pre><p>위 코드로 test.json의 내용이 문자열 객체인 json_string에 저장된다.</p><div class=post-entry style=background:unset;border:unset><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8701780565311862"></script>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8701780565311862 data-ad-slot=3363952713></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><h2 id=2-parse-json-and-ready-to-play-with-it>2. Parse JSON and Ready to play with it <a href=#2-parse-json-and-ready-to-play-with-it>¶</a><a hidden class=anchor aria-hidden=true href=#2-parse-json-and-ready-to-play-with-it>#</a></h2><p>json_string은 test.json의 내용을 바이트 스트림으로 저장하고 있을 뿐인 문자열 객체에 불과하다. 이 문자열을 JSON 문법에 맞추어 취급하기 쉬운 형태로 파싱하여야 한다. 생각만해도 번거로운 이 작업은 <code>base</code> 네임스페이스 내 <code>JSONReader</code> 클래스의 멤버 함수인 <code>Read()</code>로 쉽게 처리할 수 있다. static 함수이므로 다음과 같이 활용할 수 있다.</p><pre tabindex=0><code>std::unique_ptr&lt;base::Value&gt; json_structure;
json_structure = base::JSONReader::Read(json_str);
</code></pre><p>위 코드로 json_structure라는 <code>Value</code> 객체가 생성된다. 이를 이용하여 test.json 내의 모든 키 값들을 추출할 수 있다.</p><div class=post-entry style=background:unset;border:unset><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8701780565311862"></script>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8701780565311862 data-ad-slot=3363952713></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><h2 id=3-getting-a-dictionary-from-a-json>3. Getting a dictionary from a JSON <a href=#3-getting-a-dictionary-from-a-json>¶</a><a hidden class=anchor aria-hidden=true href=#3-getting-a-dictionary-from-a-json>#</a></h2><p>JSON은 다음의 두 개의 구조를 바탕으로 구성된다. <a href=https://www.json.org title="JSON 공식 홈페이지" target=_blank rel="noreferrer noopener nofollow">JSON 공식 홈페이지</a>에 두 구조에 대한 간략한 설명이 존재한다.</p><ul><li>Collection<ul><li>name/value pairs. In various languages this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array.</li></ul></li><li>Ordered list of values<ul><li>realized as an array, vector, list, or sequence.</li></ul></li></ul><p>JSON은 <code>Collection</code>과 <code>Ordered list</code>로 구성된다. 따라서, JSON으로부터 이 두 구조를 얻어낼 수 있다는 것은 곧, JSON을 완벽하게 활용할 수 있다는 것이다. <code>Collection</code>과 <code>Ordered list</code>를 구현하는 방법은 언어에 따라 다르다. 크로미움에서는 각각 <code>Dictionary</code>와 <code>List</code>로 표현한다. 그리고, <code>base</code> 네임스페이스에는 <code>Value</code> 클래스를 상속받는 <code>DictionaryValue</code>와 <code>ListValue</code>라는 클래스가 존재한다. 뭔가 감이 오기 시작한다. 더 진행하기에 앞서서, test.json의 내용이 다음과 같다고 가정하자.</p><pre tabindex=0><code>{
   &#34;key1&#34; : {
      &#34;key11&#34; : &#34;value11&#34;,
      &#34;key12&#34; : [ &#34;element121&#34;,
                  &#34;element122&#34;
                ]
}
</code></pre><p>JSON 전쳬가 하나의 <code>Collection</code>, 즉, <code>Dictionary</code>이다. 따라서 앞서 파싱하여 얻어낸 <code>Value</code> 객체인 json_structure로부터 <code>DictionaryValue</code> 객체를 얻어내야 한다. 그래야만 key11의 값인 &ldquo;value11"과 <code>Ordered list</code>인 key12가 포함하는 값들인 “element121&rdquo;, &ldquo;element122"를 추출할 수 있을 것이다. <code>DictionaryValue</code> 객체를 얻어내기 위해서는 <code>DictionaryValue</code> 클래스의 <code>From()</code> 함수를 이용하면 된다. static 함수이므로 다음과 같이 활용할 수 있다.</p><pre tabindex=0><code>std::unique_ptr&lt;base::DictionaryValue&gt; json_dictionary;
json_dictionary = base::DictionaryValue::From(json_structure);
</code></pre><p>위 코드로 json_dictionary라는 <code>DictionaryValue</code> 객체를 얻어낼 수 있다.</p><div class=post-entry style=background:unset;border:unset><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8701780565311862"></script>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8701780565311862 data-ad-slot=3363952713></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><h2 id=4-getting-a-value-which-type-is-string-from-a-dictionary>4. Getting a value which type is &ldquo;string&rdquo; from a dictionary <a href=#4-getting-a-value-which-type-is-string-from-a-dictionary>¶</a><a hidden class=anchor aria-hidden=true href=#4-getting-a-value-which-type-is-string-from-a-dictionary>#</a></h2><p>크로미움에서만 그런지는 모르겠지만 “.”을 이용하여 특정 키의 경로를 표현할 수 있다. 예를 들어, Key11의 주소는 &ldquo;key1.key11"이다. 이 경로를 이용하여 해당 키의 값을 추출할 수 있다. key11에 대응되는 값의 타입은 문자열이므로 <code>DictionaryValue</code> 클래스의 <code>GetString()</code> 함수를 아래와 같이 활용할 수 있다.</p><pre tabindex=0><code>std::string key11_value;
json_dictionary-&gt;GetString(&#34;key1.key11&#34;, &amp;key11_value);
</code></pre><div class=post-entry style=background:unset;border:unset><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8701780565311862"></script>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8701780565311862 data-ad-slot=3363952713></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><h2 id=5-getting-a-list-from-a-dictionary>5. Getting a list from a dictionary <a href=#5-getting-a-list-from-a-dictionary>¶</a><a hidden class=anchor aria-hidden=true href=#5-getting-a-list-from-a-dictionary>#</a></h2><p>key12는 대괄호로 둘러쌓인 Ordered list, 즉, List이다. 따라서 이번에는 <code>DictionaryValue</code> 객체로부터 <code>std::string</code>이 아닌, <code>ListValue</code>객체를 추출해야 한다. 이를 위해 <code>DictionaryValue</code> 클래스의 <code>GetList()</code> 함수를 아래와 같이 활용할 수 있다.</p><pre tabindex=0><code>base::ListValue* key12_list;
json_dictionary-&gt;GetList(&#34;key1.key12&#34;, &amp;key12_list);
</code></pre><div class=post-entry style=background:unset;border:unset><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8701780565311862"></script>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8701780565311862 data-ad-slot=3363952713></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><h2 id=6-iterate-and-getting-a-value-which-type-is-string-from-a-list>6. Iterate and getting a value which type is &ldquo;string&rdquo; from a list <a href=#6-iterate-and-getting-a-value-which-type-is-string-from-a-list>¶</a><a hidden class=anchor aria-hidden=true href=#6-iterate-and-getting-a-value-which-type-is-string-from-a-list>#</a></h2><p>앞서 얻어낸 <code>ListValue</code> 객체인 key12_list의 원소들을 순회하여 Ordered list인 key12의 모든 원소들을 추출할 수 있다. <code>DictionaryValue</code>, <code>ListValue</code> 클래스는 <code>Value</code> 클래스를 상속받는다. <code>ListValue</code>의 경우에는 원소들이 부모 클래스인 <code>Value</code>가 정의하는 멤버 변수, <code>ListStorage</code>에 저장된다. 아래와 같은 연쇄 대입 체인에 따르면,</p><pre tabindex=0><code>// base/values.h
// https://cs.chromium.org/chromium/src/base/values.h?rcl=029daddc376494ee36c5d81cc51a5ade45002fb6&amp;l=589
class ListValue : public Value {
using const_iterator = ListStorage::const_iterator;

}
// base/values.h
// https://cs.chromium.org/chromium/src/base/values.h?rcl=029daddc376494ee36c5d81cc51a5ade45002fb6&amp;l=85
ListStorage = std::vector&lt;Value&gt;;
</code></pre><p><code>ListStorage</code>는 결국 <code>std::vector</code> 객체이다. 즉, <code>std::vector</code> 객체를 순회하는 방법을 그대로 활용하여 원소들을 순회할 수 있다.</p><p><code>ListValue::const_iterator == std::vector&lt;Value>::const_iterator</code></p><p>순회 중에 방문한 원소들의 타입은 무엇일까? 타입을 알아야 값을 추출할 수 있다. 위 등식에서도 알 수 있듯이, <code>iterator</code> 또는 <code>const_iterator</code>에 의해 참조하는 각 원소들은 base::Value* 또는 const base::Value*이다. 한편, <code>Value</code> 객체의 값은 멤버 함수인 <code>GetString()</code>으로 얻어낼 수 있다.(키 값의 타입이 문자열인 경우라면) 아래가 그 예제다.</p><pre tabindex=0><code>for(base::ListValue::const_iterator it = key12_list-&gt;begin(); 
     it != key12_list-&gt;end(); ++it) {
   std::string key12_string() it-&gt;GetString();
}
</code></pre><div class=post-entry style=background:unset;border:unset><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8701780565311862"></script>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8701780565311862 data-ad-slot=3363952713></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><h2 id=full-example>Full example <a href=#full-example>¶</a><a hidden class=anchor aria-hidden=true href=#full-example>#</a></h2><p>test.json으로부터 모든 값을 추출하는 전체 예제 코드는 다음과 같다.</p><pre tabindex=0><code>base::FilePath json_path(&#34;/path/to/file/test.json&#34;);
std::string json_string;
std::unique_ptr&lt;base::Value&gt; json_structure;
std::unique_ptr&lt;base::DictionaryValue&gt; json_dictionary;
std::string key11_value;
base::ListValue* key12_list;

base::ReadFileToString(json_path, &amp;json_string);
json_structure = base::JSONReader::Read(json_str);
json_dictionary = base::DictionaryValue::From(json_structure);
json_dictionary-&gt;GetString(&#34;key1.key11&#34;, &amp;key11_value);
json_dictionary-&gt;GetList(&#34;key1.key12&#34;, &amp;key12_list);
for(base::ListValue::const_iterator it = key12_list-&gt;begin(); 
     it != key12_list-&gt;end(); ++it) {
   std::string key12_string() it-&gt;GetString();
}
</code></pre></div><div class="post-entry toc" style=margin-bottom:0><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://evening-code.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><link rel=stylesheet href=https://unpkg.com/swiper/swiper-bundle.min.css><style>.swiper{width:100%;height:200%}.swiper-slide{text-align:center;font-size:18px;width:30%;height:200%;display:-webkit-box;display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;align-items:center}@media screen and (max-width:576px){.swiper-slide{width:70%}}.swiper-slide{opacity:.5;pointer-events:none;transition:all .3s}.swiper-slide-active,.swiper-slide-prev,.swiper-slide-next{opacity:1;pointer-events:auto}.swiper-slide img{display:block;width:100%;height:100%;object-fit:cover;margin:auto}.icon{display:inline-block;width:1em;height:1em;stroke-width:0;stroke:currentColor;fill:currentColor}.news-slider__ctr{width:100%;z-index:12;margin:0;position:absolute;top:50%;-ms-transform:translateY(-50%);transform:translateY(-50%)}.news-slider__arrow{background:currentColor;opacity:.5;border:none;display:inline-flex;width:50px;height:50px;justify-content:center;align-items:center;border-radius:50%;position:absolute;top:50%;z-index:12;cursor:pointer;outline:none!important}.news-slider__arrow:focus{outline:none!important}.news-slider__arrow .icon-font{display:inline-flex}.news-slider__arrow.news-slider-prev{left:15px;transform:translateY(-50%)}.news-slider__arrow.news-slider-next{right:15px;transform:translateY(-50%)}.news-slider__pagination{text-align:center;margin-top:50px}.news-slider__pagination .swiper-pagination-bullet{width:13px;height:10px;display:inline-block;background:#fff;opacity:.2;margin:0 5px;border-radius:20px;transition:opacity .5s,background-color .5s,width .5s;transition-delay:.5s,.5s,0s}.news-slider__pagination .swiper-pagination-bullet-active{opacity:1;background:#fff;width:100px;transition-delay:0s}@media screen and (max-width:768px){.news-slider__pagination .swiper-pagination-bullet-active{width:70px}.news-slider__ctr{display:none}}</style><script src=https://unpkg.com/swiper/swiper-bundle.min.js></script>
<script>var swiper=new Swiper(".mySwiper",{effect:"coverflow",loop:!0,centeredSlides:!0,slidesPerView:"auto",coverflowEffect:{rotate:0,stretch:0,depth:0,modifier:3,slideShadows:!1},navigation:{nextEl:".news-slider-next",prevEl:".news-slider-prev"},pagination:{el:".news-slider__pagination",clickable:!0}})</script><footer class=footer style=margin-bottom:0><article class=post-entry style=transform:scale(1);background-color:var(--code-bg)><span>NEIGHBORS</span><div style=line-height:10px;display:flex;flex-wrap:wrap><a style=border-bottom:0;bottom:unset href=https://beintous.net rel="noopener noreferrer" target=_blank title="SEO "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/beintous.png alt=SEO aria-label=logo height=30></span></a>
<a style=border-bottom:0;bottom:unset href=https://traceback.co.kr rel="noopener noreferrer" target=_blank title="코딩 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/traceback.png alt=코딩 aria-label=logo height=30></span></a>
<a style=border-bottom:0;bottom:unset href=https://neppster.com rel="noopener noreferrer" target=_blank title="노하우 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/neppster.png alt=노하우 aria-label=logo height=30></span></a>
<a style=border-bottom:0;bottom:unset href=https://hannuricenter.modoo.at rel="noopener noreferrer" target=_blank title="대구 언어치료 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/hannuri.jpeg alt="대구 언어치료" aria-label=logo height=30></span></a>
<a style=border-bottom:0;bottom:unset href=https://julesflower.com rel="noopener noreferrer" target=_blank title="거제 꽃집 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/jules.jpeg alt="거제 꽃집" aria-label=logo height=30></span></a></div></article></footer><footer class=footer><span>&copy; 2022 <a href=https://baek9.github.io/>code(evening);</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer nofollow" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel="noopener noreferrer nofollow" target=_blank>PaperMod</a></span></footer><style>.sticky_share_btn{position:fixed;right:30px;bottom:30px}.share-toggle,.fixed_share{font-size:20px;width:40px;height:40px;display:flex;align-items:center;justify-content:center;cursor:pointer;border:2px solid;border-radius:50%;transition:all .5s ease-in-out;opacity:.5}.fixed_share{margin-bottom:10px}.share-toggle:hover,.fixed_share:hover{transform:scale(1.1)rotate(360deg)}.fixed_share .facebook,.fixed_share .facebook>a{color:#4267b2}</style><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css><div class=sticky_share_btn><div class=lang-switch role=button id=theme-toggle><div id=sun class=fixed_share style=color:#ff0><i class="fa fa-sun"></i></div><div id=moon class=fixed_share style=color:#000><i id=moon class="fa fa-moon"></i></div></div><div class="lang-switch fixed_share"><a href=https://baek9.github.io/en/2018/03/playing-with-json-in-chromium/>🇺🇸</a></div><div class="lang-switch fixed_share"><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" id=top-link accesskey=g><i class="fa-solid fa-arrow-up"></i></a></div></div><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"));const e=new Event("themeChanged");document.dispatchEvent(e)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script></body></html>