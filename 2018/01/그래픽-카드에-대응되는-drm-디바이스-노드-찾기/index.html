<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>그래픽 카드에 대응되는 DRM 디바이스 노드 찾기 | code(evening);</title><meta name=keywords content="DRM,DRI,udev"><meta name=description content="#DRM #DRI #udev
DRM(Direct Rendering Manager)는 DRI(Direct Rendering Infrastructure)를 지원하는 그래픽 카드를 위한 디바이스 드라이버를 말한다. DRM과 DRI에 대해서는 다음 기회에 정리해야 할 것 같다. 이 노트에서는 주 그래픽 카드에 대응되는 DRM의 디바이스 노드를 찾는 방법만 정리하였다.
보통은 /dev/dri/card0를 주 그래픽 카드에 대응되는 디바이스 노드라고 봐도 무방하다. 단, 그래픽 카드가 DRI를 지원하지 않는 경우 또는 복수의 그래픽 카드를 사용하는 경우를 제외하고 말이다. 따라서, 좀 더 확실한 방법으로 주 그래픽 카드를 식별할 수 있는 방법이 필요하다."><meta name=author content="baek9"><link rel=canonical href=https://baek9.github.io/2018/01/%EA%B7%B8%EB%9E%98%ED%94%BD-%EC%B9%B4%EB%93%9C%EC%97%90-%EB%8C%80%EC%9D%91%EB%90%98%EB%8A%94-drm-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%EB%85%B8%EB%93%9C-%EC%B0%BE%EA%B8%B0/><meta name=google-site-verification content="jxplsfLcADRts9fVC-PBsYD4NFNGHEMo08_Lj3HzSts"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.1b2afdf7fcaa8622a5c1cc704d5ca2da92c173ba5ed24382df9c72b6ca594315.css integrity="sha256-Gyr99/yqhiKlwcxwTVyi2pLBc7pe0kOC35xytspZQxU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://baek9.github.io/logo_squared.png><link rel=icon type=image/png sizes=16x16 href=https://baek9.github.io/logo_squared.png><link rel=icon type=image/png sizes=32x32 href=https://baek9.github.io/logo_squared.png><link rel=apple-touch-icon href=https://baek9.github.io/logo_squared.png><link rel=mask-icon href=https://baek9.github.io/logo_squared.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://baek9.github.io/2018/01/%EA%B7%B8%EB%9E%98%ED%94%BD-%EC%B9%B4%EB%93%9C%EC%97%90-%EB%8C%80%EC%9D%91%EB%90%98%EB%8A%94-drm-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%EB%85%B8%EB%93%9C-%EC%B0%BE%EA%B8%B0/><link rel=alternate hreflang=en href=https://baek9.github.io/en/2018/01/finding-the-drm-device-node-corresponding-to-the-graphics-card/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link href=//cdn.jsdelivr.net/gh/wan2land/d2coding/d2coding-full.css rel=stylesheet><link href=//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css rel=stylesheet type=text/css><link href=https://hangeul.pstatic.net/hangeul_static/css/nanum-square.css rel=stylesheet><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-108486276-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="그래픽 카드에 대응되는 DRM 디바이스 노드 찾기"><meta property="og:description" content="#DRM #DRI #udev
DRM(Direct Rendering Manager)는 DRI(Direct Rendering Infrastructure)를 지원하는 그래픽 카드를 위한 디바이스 드라이버를 말한다. DRM과 DRI에 대해서는 다음 기회에 정리해야 할 것 같다. 이 노트에서는 주 그래픽 카드에 대응되는 DRM의 디바이스 노드를 찾는 방법만 정리하였다.
보통은 /dev/dri/card0를 주 그래픽 카드에 대응되는 디바이스 노드라고 봐도 무방하다. 단, 그래픽 카드가 DRI를 지원하지 않는 경우 또는 복수의 그래픽 카드를 사용하는 경우를 제외하고 말이다. 따라서, 좀 더 확실한 방법으로 주 그래픽 카드를 식별할 수 있는 방법이 필요하다."><meta property="og:type" content="article"><meta property="og:url" content="https://baek9.github.io/2018/01/%EA%B7%B8%EB%9E%98%ED%94%BD-%EC%B9%B4%EB%93%9C%EC%97%90-%EB%8C%80%EC%9D%91%EB%90%98%EB%8A%94-drm-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%EB%85%B8%EB%93%9C-%EC%B0%BE%EA%B8%B0/"><meta property="og:image" content="https://baek9.github.io/logo_extended.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-14T22:00:00+00:00"><meta property="article:modified_time" content="2018-01-14T22:00:00+00:00"><meta property="og:site_name" content="code(evening); - 늦은 밤 개발 일기"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://baek9.github.io/logo_extended.png"><meta name=twitter:title content="그래픽 카드에 대응되는 DRM 디바이스 노드 찾기"><meta name=twitter:description content="#DRM #DRI #udev
DRM(Direct Rendering Manager)는 DRI(Direct Rendering Infrastructure)를 지원하는 그래픽 카드를 위한 디바이스 드라이버를 말한다. DRM과 DRI에 대해서는 다음 기회에 정리해야 할 것 같다. 이 노트에서는 주 그래픽 카드에 대응되는 DRM의 디바이스 노드를 찾는 방법만 정리하였다.
보통은 /dev/dri/card0를 주 그래픽 카드에 대응되는 디바이스 노드라고 봐도 무방하다. 단, 그래픽 카드가 DRI를 지원하지 않는 경우 또는 복수의 그래픽 카드를 사용하는 경우를 제외하고 말이다. 따라서, 좀 더 확실한 방법으로 주 그래픽 카드를 식별할 수 있는 방법이 필요하다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://baek9.github.io/posts/"},{"@type":"ListItem","position":2,"name":"그래픽 카드에 대응되는 DRM 디바이스 노드 찾기","item":"https://baek9.github.io/2018/01/%EA%B7%B8%EB%9E%98%ED%94%BD-%EC%B9%B4%EB%93%9C%EC%97%90-%EB%8C%80%EC%9D%91%EB%90%98%EB%8A%94-drm-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%EB%85%B8%EB%93%9C-%EC%B0%BE%EA%B8%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"그래픽 카드에 대응되는 DRM 디바이스 노드 찾기","name":"그래픽 카드에 대응되는 DRM 디바이스 노드 찾기","description":"#DRM #DRI #udev\nDRM(Direct Rendering Manager)는 DRI(Direct Rendering Infrastructure)를 지원하는 그래픽 카드를 위한 디바이스 드라이버를 말한다. DRM과 DRI에 대해서는 다음 기회에 정리해야 할 것 같다. 이 노트에서는 주 그래픽 카드에 대응되는 DRM의 디바이스 노드를 찾는 방법만 정리하였다.\n보통은 /dev/dri/card0를 주 그래픽 카드에 대응되는 디바이스 노드라고 봐도 무방하다. 단, 그래픽 카드가 DRI를 지원하지 않는 경우 또는 복수의 그래픽 카드를 사용하는 경우를 제외하고 말이다. 따라서, 좀 더 확실한 방법으로 주 그래픽 카드를 식별할 수 있는 방법이 필요하다.","keywords":["DRM","DRI","udev"],"articleBody":"#DRM #DRI #udev\nDRM(Direct Rendering Manager)는 DRI(Direct Rendering Infrastructure)를 지원하는 그래픽 카드를 위한 디바이스 드라이버를 말한다. DRM과 DRI에 대해서는 다음 기회에 정리해야 할 것 같다. 이 노트에서는 주 그래픽 카드에 대응되는 DRM의 디바이스 노드를 찾는 방법만 정리하였다.\n보통은 /dev/dri/card0를 주 그래픽 카드에 대응되는 디바이스 노드라고 봐도 무방하다. 단, 그래픽 카드가 DRI를 지원하지 않는 경우 또는 복수의 그래픽 카드를 사용하는 경우를 제외하고 말이다. 따라서, 좀 더 확실한 방법으로 주 그래픽 카드를 식별할 수 있는 방법이 필요하다.\n방법 1. udevadm을 이용한 방법 ¶ udevadm은 udev에 의해 생성된 디바이스 노드에 대응되는 장치의 속성들을 출력한다. 주 그래픽 카드는 boot_vga 속성의 값으로 1을 갖는다. 따라서, udevadm으로 출력한 특정 디바이스 노드의 속성 중에 boot_vga 속성의 값이 1이라면, 해당 노드는 주 그래픽 카드에 대응된다. 만약, “/dev/dri/card0”에 대응되는 그래픽 카드의 속성들을 보기 위해서는 아래와 같이 명령어를 입력하면 된다. “/dev/dri/card0”는 udev 관련 용어로 DEVNAME이라고 부르는 듯 하다.\n$ udevadm info --query=all --name=/dev/dri/card0 P: /devices/pci0000:00/0000:00:0f.0/drm/card0 N: dri/card0 E: DEVNAME=/dev/dri/card0 E: DEVPATH=/devices/pci0000:00/0000:00:0f.0/drm/card0 E: DEVTYPE=drm_minor E: ID_FOR_SEAT=drm-pci-0000_00_0f_0 E: ID_PATH=pci-0000:00:0f.0 E: ID_PATH_TAG=pci-0000_00_0f_0 E: MAJOR=226 E: MINOR=0 E: SUBSYSTEM=drm E: TAGS=:master-of-seat:uaccess💺 E: USEC_INITIALIZED=8444405 udev는 핫플러그(Hotplug) 방식으로 연결된 장치들에 대해 “/dev” 아래에 디바이스 노드들을 생성한다. 사실, udev는 sysfs가 제공하는 장치들의 정보를 가지고 “/dev”를 구성한다고 한다. 장치들의 정보는 “/sys” 아래에 계층적으로 제공되며, 이 경로는 udev 관련 용어로 DEVPATH라고 한다. 위 결과를 통해서, DEVNAME인 “/dev/dri/card0”에 대응되는 DEVPATH는 “/devices/pci0000:00/0000:00:0f.0/drm/card0”임을 알 수 있다. DEVPATH를 가지고도 아래와 같이 장치의 정보를 조회할 수 있다.\n$ udevadm info -a -p /sys/devices/pci0000:00/0000:00:0f.0/drm/card0 Udevadm info starts with the device specified by the devpath and then walks up the chain of parent devices. It prints for every device found, all possible attributes in the udev rules key format. A rule to match, can be composed by the attributes of the device and the attributes from one single parent device. looking at device '/devices/pci0000:00/0000:00:0f.0/drm/card0': KERNEL==\"card0\" SUBSYSTEM==\"drm\" DRIVER==\"\" looking at parent device '/devices/pci0000:00/0000:00:0f.0': KERNELS==\"0000:00:0f.0\" SUBSYSTEMS==\"pci\" DRIVERS==\"vmwgfx\" ATTRS{boot_vga}==\"1\" ATTRS{broken_parity_status}==\"0\" ATTRS{class}==\"0x030000\" ATTRS{consistent_dma_mask_bits}==\"32\" ATTRS{d3cold_allowed}==\"0\" ATTRS{device}==\"0x0405\" ATTRS{dma_mask_bits}==\"32\" ATTRS{driver_override}==\"(null)\" ATTRS{enable}==\"1\" ATTRS{irq}==\"16\" ATTRS{local_cpulist}==\"0-1\" ATTRS{local_cpus}==\"00000000,00000000,00000000,00000003\" ATTRS{msi_bus}==\"1\" ATTRS{numa_node}==\"-1\" ATTRS{subsystem_device}==\"0x0405\" ATTRS{subsystem_vendor}==\"0x15ad\" ATTRS{vendor}==\"0x15ad\" looking at parent device '/devices/pci0000:00': KERNELS==\"pci0000:00\" SUBSYSTEMS==\"\" DRIVERS==\"\" 방법 2. libudev를 이용한 방법 ¶ C코드에서는 libudev를 이용하여 주 그래픽 카드에 대응되는 디바이스 노드를 찾을 수 있다. weston과 GNOME이 사용하는 컴포지터인 mutter에 반영되어 있다. 이 부분은 1개 이상의 그래픽 카드가 장착된 경우를 고려한 것이다. 패치 전에는 “open(\"/dev/dri/card0\")” 형태로 하드코딩하고 있었다. 패치는 udev_enumerate_*() 함수들을 이용해 “drm/card[0-9]*“에 매칭되는 디바이스 노드들을 순회하여 boot_vga 속성을 찾는다. 결국, 해당 속성을 갖는, 즉, 주 그래픽 카드의 정보를 담은 udev_device 객체(libudev가 제공하는 구조체)를 얻어낸다. 패치의 내용은 아래 링크에서 확인할 수 있다.\nhttps://lists.freedesktop.org/archives/wayland-devel/2012-October/006033.html https://mail.gnome.org/archives/commits-list/2015-September/msg01412.html 패치로 추가되는 함수인 find_primary_gpu()는 이름부터가 매우 직관적이다. 아래는 weston 내부에서 해당 함수까지 이어지는 콜 스택의 일부이다.\nlibweston/compositor-drm.c : find_primary_gpu libweston/compositor-drm.c : drm_backend_create libweston/compositor-drm.c : weston_backend_init(WL_EXPORT) libweston/compositor.c : weston_load_module(WL_EXPORT) 참고, weston_load_module() ¶ 두 문자열 “name”과 “entrypoint”를 입력받는다. 우선 “name”을 이용하여 “.libs/[name]”에 위치한 라이브러리를 동적으로 로딩한다. “name”은 로딩하려는 라이브러리의 파일 이름을 말한다. weston은 백엔드(backend)마다 로딩할 라이브러리의 파일 이름을 하드코딩으로 매핑하고 있다. “libweston/compositor.c”의 backend_map[]이라는 문자열 배열이 그것이다. “[drm|fbdev|headless|rdp|wayland|x11]-backend.so\"가 배열에 존재하고, 배열 참조를 위한 인덱스는 “libweston/compositor.h” 의 enum 타입인 “weston_compositor_backend”를 이용한다. 즉, “backend_map[WESTON_BACKEND_DRM]”은 “drm-backend.so\"라는 문자열로 매핑된다. 이 문자열이 weston_load_moudle() 함수의 첫 번째 인자인 “name”으로 전달되는 것이다. 백엔드의 종류와 각각에 매핑되는 문자열은 아래와 같다.\n/// libweston/compositor.h enum weston_compositor_backend { WESTON_BACKEND_DRM, WESTON_BACKEND_FBDEV, WESTON_BACKEND_HEADLESS, WESTON_BACKEND_RDP, WESTON_BACKEND_WAYLAND, WESTON_BACKEND_X11, }; // libweston/compositor.c static const char * const backend_map[] = { [WESTON_BACKEND_DRM] =\t\"drm-backend.so\", [WESTON_BACKEND_FBDEV] =\t\"fbdev-backend.so\", [WESTON_BACKEND_HEADLESS] =\t\"headless-backend.so\", [WESTON_BACKEND_RDP] =\t\"rdp-backend.so\", [WESTON_BACKEND_WAYLAND] =\t\"wayland-backend.so\", [WESTON_BACKEND_X11] =\t\"x11-backend.so\", }; weston_load_module()은 인자로 받은 첫 번째 문자열인 “name”에 위치한 라이브러리를 함수 dlopen()으로 로딩한다. 인자로 받은 두 번째 문자열인 “entrypoint”는 로딩한 라이브러리 내에서 호출할 함수의 이름을 의미한다. 즉, dlsym을 이용하여 “entrypoint”, 즉, 함수 weston_backend_init()의 주소를 찾아 호출한다. libdl은 이처럼 런타임에 라이브러리를 로딩하고 해당 라이브러리의 심볼들에 접근할 수 있게끔 도와준다. weston_load_module()에 도달하기까지의 콜 스택은 다음과 같다.\nlibweston/compositor.c : weston_load_module(WL_EXPORT) libweston/compositor.c : weston_compositor_load_backend(WL_EXPORT) compositor/main.c : weston_compositor_load_backend() compositor/main.c : load_backend() compositor/main.c : main() ","wordCount":"609","inLanguage":"ko","datePublished":"2018-01-14T22:00:00Z","dateModified":"2018-01-14T22:00:00Z","author":{"@type":"Person","name":"baek9","url":"https://baek9.github.io/"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://baek9.github.io/2018/01/%EA%B7%B8%EB%9E%98%ED%94%BD-%EC%B9%B4%EB%93%9C%EC%97%90-%EB%8C%80%EC%9D%91%EB%90%98%EB%8A%94-drm-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%EB%85%B8%EB%93%9C-%EC%B0%BE%EA%B8%B0/"},"publisher":{"@type":"Organization","name":"code(evening);","logo":{"@type":"ImageObject","url":"https://baek9.github.io/logo_squared.png"}}}</script></head><body id=top><style>.button-62{background:linear-gradient(to bottom right,#EF4765,#FF9A5A);border:0;border-radius:12px;cursor:pointer;display:inherit;font-family:-apple-system,system-ui,segoe ui,Roboto,Helvetica,Arial,sans-serif;font-size:16px;font-weight:500;line-height:2.5;outline:transparent;padding:0 1rem;text-align:center;text-decoration:none;transition:box-shadow .2s ease-in-out;user-select:none;-webkit-user-select:none;touch-action:manipulation;white-space:nowrap}.button-62:not([disabled]):focus{box-shadow:0 0 .25rem rgba(0,0,0,.5),-.125rem -.125rem 1rem rgba(239,71,101,.5),.125rem .125rem 1rem rgba(255,154,90,.5)}.button-62:not([disabled]):hover{box-shadow:0 0 .25rem rgba(0,0,0,.5),-.125rem -.125rem 1rem rgba(239,71,101,.5),.125rem .125rem 1rem rgba(255,154,90,.5)}</style><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=social-icons><a href=https://baek9.github.io/ accesskey=h title="늦은 밤 개발 일기 (Alt + H)"><img src=https://baek9.github.io/logo.png style=border-radius:5px;padding:6px;background:#fff alt=logo aria-label=logo height=45>늦은 밤 개발 일기</a></div><div class="social-icons logo-switches"><ul id=menu><li><div style=vertical-align:center;line-height:16px><a href=https://linkedin.com/in/thnam target=_blank rel="noopener noreferrer me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></div></li><li><div style=vertical-align:center;line-height:16px><a href=https://twitter.com/thnam_ target=_blank rel="noopener noreferrer me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></li><li><div style=vertical-align:center;line-height:16px><a href=https://github.com/baek9 target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></li><li><div style=vertical-align:center;line-height:16px><a href=https://baek9.github.io/index.xml target=_blank rel="noopener noreferrer me" title=Rss><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div></li></ul></div></div><ul id=menu><li><a href=https://baek9.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://baek9.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://baek9.github.io/about_me/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main style=min-height:unset><style>.post-title{margin-bottom:2px;font-size:30px}.post-content h2{font-size:25px}.entry-footer{font-size:10px}</style><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://baek9.github.io/>홈</a>&nbsp;»&nbsp;<a href=https://baek9.github.io/posts/>Posts</a></div><h1 class=post-title>그래픽 카드에 대응되는 DRM 디바이스 노드 찾기</h1><div class=post-meta><span title='2018-01-14 22:00:00 +0000 UTC'>1월 14, 2018</span>&nbsp;·&nbsp;baek9&nbsp;|&nbsp;번역:<ul class=i18n_list><li><a href=https://baek9.github.io/en/2018/01/finding-the-drm-device-node-corresponding-to-the-graphics-card/>🇺🇸</a></li></ul></div></header><style>#figmask{width:100%}#figmask{position:relative}#figmask:after{width:100%;content:'';display:block;position:absolute;top:0;left:0;background:linear-gradient(to top,var(--entry) 0,transparent 5em);height:100%}</style><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#방법-1-udevadm을-이용한-방법>방법 1. <code>udevadm</code>을 이용한 방법</a></li><li><a href=#방법-2-libudev를-이용한-방법>방법 2. libudev를 이용한 방법</a></li><li><a href=#참고-weston_load_module>참고, <code>weston_load_module()</code></a></li></ul></nav></div></details></div><style>.highlight{margin-bottom:5.5em;font-family:poppins,sans-serif;font-weight:700;text-decoration:none;background:linear-gradient(to right,#64ffff,#64ffff),linear-gradient(to right,red,#4378ff,#64ffff);background-size:100% 3px,0 3px;background-position:100% 100%,0 100%;background-repeat:no-repeat;transition:background-size 400ms}</style><div class=post-content><p>#DRM #DRI #udev</p><p>DRM(Direct Rendering Manager)는 DRI(Direct Rendering Infrastructure)를 지원하는 그래픽 카드를 위한 디바이스 드라이버를 말한다. DRM과 DRI에 대해서는 다음 기회에 정리해야 할 것 같다. 이 노트에서는 주 그래픽 카드에 대응되는 DRM의 디바이스 노드를 찾는 방법만 정리하였다.</p><p>보통은 /dev/dri/card0를 주 그래픽 카드에 대응되는 디바이스 노드라고 봐도 무방하다. 단, 그래픽 카드가 DRI를 지원하지 않는 경우 또는 복수의 그래픽 카드를 사용하는 경우를 제외하고 말이다. 따라서, 좀 더 확실한 방법으로 주 그래픽 카드를 식별할 수 있는 방법이 필요하다.</p><div class=post-entry style=background:unset;border:unset><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8701780565311862"></script>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8701780565311862 data-ad-slot=3363952713></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><h2 id=방법-1-udevadm을-이용한-방법>방법 1. <code>udevadm</code>을 이용한 방법 <a href=#%eb%b0%a9%eb%b2%95-1-udevadm%ec%9d%84-%ec%9d%b4%ec%9a%a9%ed%95%9c-%eb%b0%a9%eb%b2%95>¶</a><a hidden class=anchor aria-hidden=true href=#방법-1-udevadm을-이용한-방법>#</a></h2><p><code>udevadm</code>은 <code>udev</code>에 의해 생성된 디바이스 노드에 대응되는 장치의 속성들을 출력한다. 주 그래픽 카드는 <code>boot_vga</code> 속성의 값으로 1을 갖는다. 따라서, <code>udevadm</code>으로 출력한 특정 디바이스 노드의 속성 중에 <code>boot_vga</code> 속성의 값이 1이라면, 해당 노드는 주 그래픽 카드에 대응된다. 만약, “/dev/dri/card0”에 대응되는 그래픽 카드의 속성들을 보기 위해서는 아래와 같이 명령어를 입력하면 된다. “/dev/dri/card0”는 <code>udev</code> 관련 용어로 <code>DEVNAME</code>이라고 부르는 듯 하다.</p><pre tabindex=0><code>	$ udevadm info --query=all --name=/dev/dri/card0
	
	P: /devices/pci0000:00/0000:00:0f.0/drm/card0
	N: dri/card0
	E: DEVNAME=/dev/dri/card0
	E: DEVPATH=/devices/pci0000:00/0000:00:0f.0/drm/card0
	E: DEVTYPE=drm_minor
	E: ID_FOR_SEAT=drm-pci-0000_00_0f_0
	E: ID_PATH=pci-0000:00:0f.0
	E: ID_PATH_TAG=pci-0000_00_0f_0
	E: MAJOR=226
	E: MINOR=0
	E: SUBSYSTEM=drm
	E: TAGS=:master-of-seat:uaccess💺
	E: USEC_INITIALIZED=8444405
</code></pre><p><code>udev</code>는 핫플러그(Hotplug) 방식으로 연결된 장치들에 대해 “/dev” 아래에 디바이스 노드들을 생성한다. 사실, <code>udev</code>는 <code>sysfs</code>가 제공하는 장치들의 정보를 가지고 “/dev”를 구성한다고 한다. 장치들의 정보는 “/sys” 아래에 계층적으로 제공되며, 이 경로는 <code>udev</code> 관련 용어로 <code>DEVPATH</code>라고 한다. 위 결과를 통해서, <code>DEVNAME</code>인 “/dev/dri/card0”에 대응되는 <code>DEVPATH</code>는 “/devices/pci0000:00/0000:00:0f.0/drm/card0”임을 알 수 있다. <code>DEVPATH</code>를 가지고도 아래와 같이 장치의 정보를 조회할 수 있다.</p><pre tabindex=0><code>	$ udevadm info -a -p /sys/devices/pci0000:00/0000:00:0f.0/drm/card0
	
	Udevadm info starts with the device specified by the devpath and then
	walks up the chain of parent devices. It prints for every device
	found, all possible attributes in the udev rules key format.
	A rule to match, can be composed by the attributes of the device
	and the attributes from one single parent device.
	
	  looking at device &#39;/devices/pci0000:00/0000:00:0f.0/drm/card0&#39;:
	    KERNEL==&#34;card0&#34;
	    SUBSYSTEM==&#34;drm&#34;
	    DRIVER==&#34;&#34;
	
	  looking at parent device &#39;/devices/pci0000:00/0000:00:0f.0&#39;:
	    KERNELS==&#34;0000:00:0f.0&#34;
	    SUBSYSTEMS==&#34;pci&#34;
	    DRIVERS==&#34;vmwgfx&#34;
	    ATTRS{boot_vga}==&#34;1&#34;
	    ATTRS{broken_parity_status}==&#34;0&#34;
	    ATTRS{class}==&#34;0x030000&#34;
	    ATTRS{consistent_dma_mask_bits}==&#34;32&#34;
	    ATTRS{d3cold_allowed}==&#34;0&#34;
	    ATTRS{device}==&#34;0x0405&#34;
	    ATTRS{dma_mask_bits}==&#34;32&#34;
	    ATTRS{driver_override}==&#34;(null)&#34;
	    ATTRS{enable}==&#34;1&#34;
	    ATTRS{irq}==&#34;16&#34;
	    ATTRS{local_cpulist}==&#34;0-1&#34;
	    ATTRS{local_cpus}==&#34;00000000,00000000,00000000,00000003&#34;
	    ATTRS{msi_bus}==&#34;1&#34;
	    ATTRS{numa_node}==&#34;-1&#34;
	    ATTRS{subsystem_device}==&#34;0x0405&#34;
	    ATTRS{subsystem_vendor}==&#34;0x15ad&#34;
	    ATTRS{vendor}==&#34;0x15ad&#34;
	
	  looking at parent device &#39;/devices/pci0000:00&#39;:
	    KERNELS==&#34;pci0000:00&#34;
	    SUBSYSTEMS==&#34;&#34;
	    DRIVERS==&#34;&#34;
</code></pre><div class=post-entry style=background:unset;border:unset><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8701780565311862"></script>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8701780565311862 data-ad-slot=3363952713></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><h2 id=방법-2-libudev를-이용한-방법>방법 2. libudev를 이용한 방법 <a href=#%eb%b0%a9%eb%b2%95-2-libudev%eb%a5%bc-%ec%9d%b4%ec%9a%a9%ed%95%9c-%eb%b0%a9%eb%b2%95>¶</a><a hidden class=anchor aria-hidden=true href=#방법-2-libudev를-이용한-방법>#</a></h2><p>C코드에서는 <code>libudev</code>를 이용하여 주 그래픽 카드에 대응되는 디바이스 노드를 찾을 수 있다. <code>weston</code>과 <code>GNOME</code>이 사용하는 컴포지터인 <code>mutter</code>에 반영되어 있다. 이 부분은 1개 이상의 그래픽 카드가 장착된 경우를 고려한 것이다. 패치 전에는 “open("/dev/dri/card0")” 형태로 하드코딩하고 있었다. 패치는 <code>udev_enumerate_*()</code> 함수들을 이용해 &ldquo;drm/card[0-9]*&ldquo;에 매칭되는 디바이스 노드들을 순회하여 <code>boot_vga</code> 속성을 찾는다. 결국, 해당 속성을 갖는, 즉, 주 그래픽 카드의 정보를 담은 <code>udev_device</code> 객체(libudev가 제공하는 구조체)를 얻어낸다. 패치의 내용은 아래 링크에서 확인할 수 있다.</p><ul><li><a href=https://lists.freedesktop.org/archives/wayland-devel/2012-October/006033.html title=https://lists.freedesktop.org/archives/wayland-devel/2012-October/006033.html target=_blank rel="noreferrer noopener nofollow">https://lists.freedesktop.org/archives/wayland-devel/2012-October/006033.html</a></li><li><a href=https://mail.gnome.org/archives/commits-list/2015-September/msg01412.html title=https://mail.gnome.org/archives/commits-list/2015-September/msg01412.html target=_blank rel="noreferrer noopener nofollow">https://mail.gnome.org/archives/commits-list/2015-September/msg01412.html</a></li></ul><p>패치로 추가되는 함수인 <code>find_primary_gpu()</code>는 이름부터가 매우 직관적이다. 아래는 <code>weston</code> 내부에서 해당 함수까지 이어지는 콜 스택의 일부이다.</p><ul><li>libweston/compositor-drm.c : find_primary_gpu</li><li>libweston/compositor-drm.c : drm_backend_create</li><li>libweston/compositor-drm.c : weston_backend_init(WL_EXPORT)</li><li>libweston/compositor.c : weston_load_module(WL_EXPORT)</li></ul><div class=post-entry style=background:unset;border:unset><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8701780565311862"></script>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8701780565311862 data-ad-slot=3363952713></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><h2 id=참고-weston_load_module>참고, <code>weston_load_module()</code> <a href=#%ec%b0%b8%ea%b3%a0-weston_load_module>¶</a><a hidden class=anchor aria-hidden=true href=#참고-weston_load_module>#</a></h2><p>두 문자열 “name”과 “entrypoint”를 입력받는다. 우선 “name”을 이용하여 “.libs/[name]”에 위치한 라이브러리를 동적으로 로딩한다. “name”은 로딩하려는 라이브러리의 파일 이름을 말한다. <code>weston</code>은 백엔드(backend)마다 로딩할 라이브러리의 파일 이름을 하드코딩으로 매핑하고 있다. “libweston/compositor.c”의 <code>backend_map[]</code>이라는 문자열 배열이 그것이다. &ldquo;[drm|fbdev|headless|rdp|wayland|x11]-backend.so"가 배열에 존재하고, 배열 참조를 위한 인덱스는 “libweston/compositor.h” 의 enum 타입인 “weston_compositor_backend”를 이용한다. 즉, “backend_map[WESTON_BACKEND_DRM]”은 &ldquo;drm-backend.so"라는 문자열로 매핑된다. 이 문자열이 <code>weston_load_moudle()</code> 함수의 첫 번째 인자인 “name”으로 전달되는 것이다. 백엔드의 종류와 각각에 매핑되는 문자열은 아래와 같다.</p><pre tabindex=0><code>/// libweston/compositor.h
enum weston_compositor_backend {
	WESTON_BACKEND_DRM,
	WESTON_BACKEND_FBDEV,
	WESTON_BACKEND_HEADLESS,
	WESTON_BACKEND_RDP,
	WESTON_BACKEND_WAYLAND,
	WESTON_BACKEND_X11,
};
			
// libweston/compositor.c
static const char * const backend_map[] = {
	[WESTON_BACKEND_DRM] =		&#34;drm-backend.so&#34;,
	[WESTON_BACKEND_FBDEV] =	&#34;fbdev-backend.so&#34;,
	[WESTON_BACKEND_HEADLESS] =	&#34;headless-backend.so&#34;,
	[WESTON_BACKEND_RDP] =		&#34;rdp-backend.so&#34;,
	[WESTON_BACKEND_WAYLAND] =	&#34;wayland-backend.so&#34;,
	[WESTON_BACKEND_X11] =		&#34;x11-backend.so&#34;,
};
</code></pre><p><code>weston_load_module()</code>은 인자로 받은 첫 번째 문자열인 “name”에 위치한 라이브러리를 함수 <code>dlopen()</code>으로 로딩한다. 인자로 받은 두 번째 문자열인 “entrypoint”는 로딩한 라이브러리 내에서 호출할 함수의 이름을 의미한다. 즉, <code>dlsym</code>을 이용하여 “entrypoint”, 즉, 함수 <code>weston_backend_init()</code>의 주소를 찾아 호출한다. <code>libdl</code>은 이처럼 런타임에 라이브러리를 로딩하고 해당 라이브러리의 심볼들에 접근할 수 있게끔 도와준다. <code>weston_load_module()</code>에 도달하기까지의 콜 스택은 다음과 같다.</p><ul><li>libweston/compositor.c : weston_load_module(WL_EXPORT)</li><li>libweston/compositor.c : weston_compositor_load_backend(WL_EXPORT)</li><li>compositor/main.c : weston_compositor_load_backend()</li><li>compositor/main.c : load_backend()</li><li>compositor/main.c : main()</li></ul></div><div class="post-entry toc" style=margin-bottom:0><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://evening-code.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><link rel=stylesheet href=https://unpkg.com/swiper/swiper-bundle.min.css><style>.swiper{width:100%;height:200%}.swiper-slide{text-align:center;font-size:18px;width:30%;height:200%;display:-webkit-box;display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;align-items:center}@media screen and (max-width:576px){.swiper-slide{width:70%}}.swiper-slide{opacity:.5;pointer-events:none;transition:all .3s}.swiper-slide-active,.swiper-slide-prev,.swiper-slide-next{opacity:1;pointer-events:auto}.swiper-slide img{display:block;width:100%;height:100%;object-fit:cover;margin:auto}.icon{display:inline-block;width:1em;height:1em;stroke-width:0;stroke:currentColor;fill:currentColor}.news-slider__ctr{width:100%;z-index:12;margin:0;position:absolute;top:50%;-ms-transform:translateY(-50%);transform:translateY(-50%)}.news-slider__arrow{background:currentColor;opacity:.5;border:none;display:inline-flex;width:50px;height:50px;justify-content:center;align-items:center;border-radius:50%;position:absolute;top:50%;z-index:12;cursor:pointer;outline:none!important}.news-slider__arrow:focus{outline:none!important}.news-slider__arrow .icon-font{display:inline-flex}.news-slider__arrow.news-slider-prev{left:15px;transform:translateY(-50%)}.news-slider__arrow.news-slider-next{right:15px;transform:translateY(-50%)}.news-slider__pagination{text-align:center;margin-top:50px}.news-slider__pagination .swiper-pagination-bullet{width:13px;height:10px;display:inline-block;background:#fff;opacity:.2;margin:0 5px;border-radius:20px;transition:opacity .5s,background-color .5s,width .5s;transition-delay:.5s,.5s,0s}.news-slider__pagination .swiper-pagination-bullet-active{opacity:1;background:#fff;width:100px;transition-delay:0s}@media screen and (max-width:768px){.news-slider__pagination .swiper-pagination-bullet-active{width:70px}.news-slider__ctr{display:none}}</style><script src=https://unpkg.com/swiper/swiper-bundle.min.js></script>
<script>var swiper=new Swiper(".mySwiper",{effect:"coverflow",loop:!0,centeredSlides:!0,slidesPerView:"auto",coverflowEffect:{rotate:0,stretch:0,depth:0,modifier:3,slideShadows:!1},navigation:{nextEl:".news-slider-next",prevEl:".news-slider-prev"},pagination:{el:".news-slider__pagination",clickable:!0}})</script><footer class=footer style=margin-bottom:0><article class=post-entry style=transform:scale(1);background-color:var(--code-bg)><span>NEIGHBORS</span><div style=line-height:10px;display:flex;flex-wrap:wrap><a style=border-bottom:0;bottom:unset href=https://beintous.net rel="noopener noreferrer" target=_blank title="SEO "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/beintous.png alt=SEO aria-label=logo height=30></span></a>
<a style=border-bottom:0;bottom:unset href=https://traceback.co.kr rel="noopener noreferrer" target=_blank title="코딩 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/traceback.png alt=코딩 aria-label=logo height=30></span></a>
<a style=border-bottom:0;bottom:unset href=https://neppster.com rel="noopener noreferrer" target=_blank title="노하우 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/neppster.png alt=노하우 aria-label=logo height=30></span></a>
<a style=border-bottom:0;bottom:unset href=https://hannuricenter.modoo.at rel="noopener noreferrer" target=_blank title="대구 언어치료 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/hannuri.jpeg alt="대구 언어치료" aria-label=logo height=30></span></a>
<a style=border-bottom:0;bottom:unset href=https://julesflower.com rel="noopener noreferrer" target=_blank title="거제 꽃집 "><span><img style=margin-inline-start:14px;border-radius:3px src=https://baek9.github.io/jules.jpeg alt="거제 꽃집" aria-label=logo height=30></span></a></div></article></footer><footer class=footer><span>&copy; 2022 <a href=https://baek9.github.io/>code(evening);</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer nofollow" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel="noopener noreferrer nofollow" target=_blank>PaperMod</a></span></footer><style>.sticky_share_btn{position:fixed;right:30px;bottom:30px}.share-toggle,.fixed_share{font-size:20px;width:40px;height:40px;display:flex;align-items:center;justify-content:center;cursor:pointer;border:2px solid;border-radius:50%;transition:all .5s ease-in-out;opacity:.5}.fixed_share{margin-bottom:10px}.share-toggle:hover,.fixed_share:hover{transform:scale(1.1)rotate(360deg)}.fixed_share .facebook,.fixed_share .facebook>a{color:#4267b2}</style><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css><div class=sticky_share_btn><div class=lang-switch role=button id=theme-toggle><div id=sun class=fixed_share style=color:#ff0><i class="fa fa-sun"></i></div><div id=moon class=fixed_share style=color:#000><i id=moon class="fa fa-moon"></i></div></div><div class="lang-switch fixed_share"><a href=https://baek9.github.io/en/2018/01/finding-the-drm-device-node-corresponding-to-the-graphics-card/>🇺🇸</a></div><div class="lang-switch fixed_share"><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" id=top-link accesskey=g><i class="fa-solid fa-arrow-up"></i></a></div></div><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"));const e=new Event("themeChanged");document.dispatchEvent(e)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script></body></html>